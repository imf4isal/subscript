WEBVTT

00:00.180 --> 00:07.110
The Transmission control protocol, one of the most popular protocols there is, and most applications

00:07.110 --> 00:08.190
are built on top of it.

00:08.280 --> 00:09.780
Most reliable application.

00:09.780 --> 00:13.530
It is the reliable protocol, and we use it all the time.

00:13.710 --> 00:16.350
It has its pros and definitely has its cons.

00:16.350 --> 00:20.580
And this is the section that we're going to talk about it, transmission control protocol.

00:21.330 --> 00:23.220
Let's discuss this.

00:23.790 --> 00:27.720
Let's unpack and let's demystify this thing.

00:28.440 --> 00:29.250
Let's jump into it.

00:29.730 --> 00:34.500
The transmission control protocol and I'm going to disappear off if I'm covering a slide or not.

00:34.590 --> 00:34.980
Right.

00:35.040 --> 00:36.390
As as necessary.

00:36.390 --> 00:44.880
But it stands for the transmission control protocol and the focus on this or transmission and control.

00:45.390 --> 00:51.270
It controls the transmission because usually it does transmission, but it doesn't control it at all.

00:51.570 --> 00:52.860
Just sends stuff.

00:52.860 --> 00:57.150
You know, this is controlling the protocol and it's a for protocol.

00:57.150 --> 00:58.350
Exactly like UDP.

00:59.130 --> 01:04.530
That means we get beautiful ports and we get more control there.

01:04.770 --> 01:06.240
We get so much algorithms here.

01:06.240 --> 01:10.620
We're going to talk about all the algorithms that TCP uses to control the transmission.

01:10.620 --> 01:11.370
What does that mean?

01:11.850 --> 01:15.180
Ability to address processes in host using ports?

01:15.330 --> 01:17.280
Yeah, same concept.

01:17.280 --> 01:19.860
We talked about UDP exist in TCB.

01:20.490 --> 01:23.010
The ability now that we have ports.

01:23.550 --> 01:26.160
Right, which is something did exist in IP.

01:26.400 --> 01:26.690
Right.

01:26.700 --> 01:34.440
And third protocol now we can send multiple requests to the same host, but two different applications.

01:34.440 --> 01:39.630
So process one can receive a packet process to kind of see what different kind of content is really

01:39.630 --> 01:45.960
kind of different all using the same, you know, IP, IP host effectively.

01:45.960 --> 01:48.960
And this is ideal for multiplexing and multiplexing, right?

01:49.770 --> 01:53.820
It controls the transmission, unlike UDP, which is literally a firehose.

01:53.820 --> 01:57.510
Just we can send it and this virus can be dangerous.

01:57.950 --> 02:05.820
And that's why firewall firewalls sometimes block UDP because of this problem, because of firehose,

02:05.820 --> 02:07.490
firehose and firewall.

02:08.140 --> 02:09.480
It's a tongue twister, man.

02:10.500 --> 02:16.410
Now, that is a concept of a connection, something that never existing, never existed, and the IP

02:16.770 --> 02:22.260
never existed in the UDP connection, which requires the mother connection.

02:22.260 --> 02:23.370
That means a session.

02:24.180 --> 02:32.220
That means there is knowledge between the client and the server and this knowledge is a state they store

02:32.220 --> 02:34.290
on both the server and the client.

02:36.320 --> 02:37.540
I miss his memory.

02:38.640 --> 02:42.000
There is a state, there is a stateful.

02:42.540 --> 02:46.080
And to build that, a state required a handshake.

02:46.770 --> 02:47.400
And look at this.

02:49.370 --> 02:50.480
Oh, my God.

02:50.510 --> 02:50.990
How many?

02:50.990 --> 02:52.220
How much hater does it need?

02:53.000 --> 02:55.760
It needs a 20 bytes.

02:56.090 --> 02:56.450
How much?

02:56.450 --> 02:58.790
The IP packet needs 20.

02:59.540 --> 03:05.720
So 24 headers for the IP packet and another 20 byte header for this segment.

03:05.840 --> 03:06.140
Right.

03:07.100 --> 03:09.200
So it's a TCP segment.

03:09.380 --> 03:10.610
It's an IP packet.

03:10.760 --> 03:13.550
It's a layer two frame, Ethernet frame.

03:14.750 --> 03:16.370
And it can go up to 60.

03:16.490 --> 03:17.930
Exactly like the IP.

03:17.930 --> 03:29.240
So you can worst case scenario, you can have 120 bytes in a TCP IP transmission just off nasty headers.

03:29.580 --> 03:30.020
That's it.

03:30.020 --> 03:30.870
That's the maximum.

03:30.890 --> 03:32.960
I don't know if you can ever go there.

03:33.680 --> 03:39.440
Theoretically speaking, but yeah, 60 plus 60.

03:39.440 --> 03:46.580
That's 120 bytes image of sending just the less and the that's a search command and then add another

03:47.000 --> 03:50.900
one to any bytes that will speak of a wasteful.

03:51.740 --> 03:53.570
So stateful is a very stateful protocol.

03:55.590 --> 03:58.650
Use cases at I'm not going to cover my head.

03:58.650 --> 04:00.790
There is B, here is another server.

04:00.810 --> 04:01.980
Here is you can see it.

04:02.280 --> 04:03.420
It's B, that's it.

04:03.720 --> 04:04.920
That's what it is right here.

04:05.670 --> 04:07.740
I didn't see my saw so I can see my hand yesterday.

04:07.740 --> 04:08.600
I talk a lot.

04:08.620 --> 04:10.080
I move my hand a lot.

04:10.080 --> 04:15.000
So reliable communication that I mentioned that this slides are available.

04:15.000 --> 04:20.880
So go to the first lecture and download this entire slide and you can see everything from reliable communication.

04:20.880 --> 04:24.240
That's what you use cases for these to be reliable communication.

04:24.240 --> 04:29.580
If you've want to chat, you probably don't want their message to be received scrambled and you cannot

04:29.580 --> 04:32.910
possibly construct that message.

04:33.030 --> 04:33.750
It's a message.

04:33.750 --> 04:38.280
How would you how would you know what the person wanted to say?

04:39.060 --> 04:46.260
You cannot is not a video where you get, okay, this this frame looks like this frame you can extrapolate.

04:46.770 --> 04:51.960
But this is text says if I say hello, you cannot say, hey, go away.

04:51.960 --> 04:54.300
You can just change the message, right?

04:55.110 --> 05:01.260
So reliable communications, very critical of remote shell or database connections.

05:01.590 --> 05:06.000
You probably don't want to send a sequel and that sequel is jumbled to do something else.

05:06.000 --> 05:14.760
Imagine like a you send an insert or a select staff from employees and it's scrambled to try and get

05:14.760 --> 05:15.720
table employees.

05:16.410 --> 05:17.700
That would be a disaster, wouldn't it?

05:18.390 --> 05:21.570
Probably that that's kind of a exaggeration.

05:21.570 --> 05:22.290
You get the point.

05:22.530 --> 05:26.400
You might just like select turns into truncate she's all right.

05:26.670 --> 05:32.280
So web communication yet all web stuff is done through the HDTV protocol.

05:32.700 --> 05:32.970
All right.

05:33.180 --> 05:37.880
SDB is built on DHCP at the is to be one and CDB two.

05:38.080 --> 05:43.170
TV three is built in quick, which is built on UDP, which is a whole revamping of the TCP.

05:43.590 --> 05:54.840
Quick is exactly like TCP, but it it, it is rebuilt with more features and with awareness when it

05:54.840 --> 06:01.590
comes to the content that is being sent, you know, there's streams of calls of streams, channels,

06:01.590 --> 06:02.460
if you want to call them.

06:02.460 --> 06:06.600
I like the word channel better than stream, but is not our topic.

06:07.350 --> 06:12.900
Anybody that excellent communication a can talk to BMB can talk to a you know.

06:13.990 --> 06:16.660
A Kentucky Derby and beat Kentucky.

06:16.930 --> 06:17.890
There is no order.

06:18.310 --> 06:18.640
Right.

06:19.090 --> 06:21.580
SDP is actually a request response.

06:21.580 --> 06:27.970
So you send a request synchronously and you wait for a response and we will send back the response or

06:28.090 --> 06:29.140
request response.

06:29.470 --> 06:32.680
TCP is not a request response system.

06:33.040 --> 06:35.230
It's a it's a bi directional communication.

06:35.530 --> 06:38.740
Just dislike web sockets if you're familiar with that.

06:40.890 --> 06:41.430
All right.

06:41.430 --> 06:42.750
TCP connection.

06:43.440 --> 06:45.150
The concept of a connection, guys.

06:46.080 --> 06:48.300
The concept of a connection here is now.

06:49.380 --> 06:50.190
We have a state.

06:50.370 --> 06:53.520
We have knowledge between the client of the server.

06:53.940 --> 06:55.470
We establish knowledge.

06:56.450 --> 06:57.840
We handshake.

06:58.400 --> 07:01.370
And then once I know you, I'm going to save a state.

07:01.370 --> 07:05.780
I'm going to save a session and layer a five that identifies you.

07:06.290 --> 07:15.380
And if you better exist in this list, if you send me something in TCP and you claim to be a TCP segment

07:15.860 --> 07:19.100
and you don't have a connection with me, I'm going to drop you.

07:21.060 --> 07:22.710
So there is no spoofing.

07:23.520 --> 07:24.810
You can't spoof Merman.

07:26.070 --> 07:28.800
Connection is an agreement between a client and server.

07:29.280 --> 07:30.000
It's an agreement.

07:30.210 --> 07:32.790
And we were going to talk about how this agreement is done in a minute.

07:33.780 --> 07:35.460
Must create a connection to send data.

07:35.880 --> 07:44.790
That is one of the most powerful concept in DCP and also latency inducing, if you will, because now

07:44.790 --> 07:47.610
you want you to do this whole handshake just to send data.

07:47.700 --> 07:48.990
Oh, my gosh.

07:49.380 --> 07:50.060
Why?

07:50.730 --> 07:51.090
Right.

07:51.660 --> 07:53.700
The reason is because of security.

07:53.970 --> 07:54.450
Reason.

07:54.450 --> 07:55.230
Because of.

07:57.900 --> 07:58.200
Really?

07:58.200 --> 07:58.960
That's pretty much it.

07:58.980 --> 08:02.430
I think security is one of the major reasons of the connection.

08:02.580 --> 08:04.310
They can just send data.

08:04.320 --> 08:07.470
You know, we have an establishment.

08:07.470 --> 08:08.430
We have authentication.

08:08.430 --> 08:09.690
I know you write.

08:11.580 --> 08:13.200
Well, it's a mini authenticate.

08:13.200 --> 08:17.440
I don't call it full authentication because literally anyone can connect to anyone.

08:17.460 --> 08:20.460
I don't know if you're an attacker or a good, good guy.

08:20.730 --> 08:22.860
You know, someone is connected to me.

08:22.860 --> 08:26.820
I don't know who you are, but at least I know that you connected to me.

08:26.820 --> 08:27.760
I established.

08:27.760 --> 08:30.750
Then you can just send me data without connection.

08:31.110 --> 08:33.720
I can choose to block you if I want to.

08:35.010 --> 08:37.200
And connection is identified by four properties.

08:37.200 --> 08:41.610
We talked about this source IP, source port, destination IP, destination port.

08:41.880 --> 08:48.780
All these four pairs which are both from layer after layer three are taken the operating system, hash

08:48.780 --> 08:51.330
it and preserve one hash.

08:51.600 --> 08:57.630
And that hash is locked up in a lookup in the operating system and that matches something called a file

08:57.630 --> 08:59.880
descriptor in the operating system.

09:00.420 --> 09:06.990
And I find the sculpture contains the session effectively the state and this is usually in memory but

09:07.230 --> 09:08.850
also can be preserved disk.

09:09.030 --> 09:13.020
I'm not quite sure about that, but it takes finite amount of memory.

09:13.410 --> 09:18.480
So that's how you know, if there's a connection or not, you hash it and you look up.

09:19.260 --> 09:21.360
If it's there, if it's there, you have a connection.

09:21.360 --> 09:28.740
If it's not there, fail or drop the segment or return ICMP message saying, Hey, who are you?

09:30.830 --> 09:32.720
Can't send data outside the nation.

09:32.720 --> 09:36.140
Talk about that sometimes called socket or find the sculptor.

09:36.140 --> 09:39.800
We talked about that the concept of a socket or if I discover is a layer five.

09:39.800 --> 09:42.940
I think we talked about that because it's a session there.

09:43.220 --> 09:46.760
Now we're talking about not just stateless segments being sent.

09:46.850 --> 09:47.960
Know I have knowledge.

09:48.410 --> 09:48.770
All right.

09:49.040 --> 09:50.120
I have knowledge about this.

09:50.120 --> 09:52.130
Think I have a session that is established.

09:52.370 --> 09:53.630
I'm stalling the session.

09:53.930 --> 09:57.500
That's why layer five is effectively state stateful protocol.

09:57.500 --> 09:59.480
Right now.

09:59.480 --> 10:04.670
We have this session and then it requires a three way it handshake, which you're going to we're going

10:04.670 --> 10:05.360
to do in a minute.

10:05.860 --> 10:06.140
Right.

10:06.440 --> 10:09.950
And segments that you send every segment.

10:09.950 --> 10:11.180
So you start with a sequence.

10:12.280 --> 10:14.890
He's won and then he's ended.

10:15.160 --> 10:19.780
And then you add the length of the package and then you send two, three, four, five.

10:20.260 --> 10:22.810
So these segments are arriving in a certain order.

10:23.410 --> 10:30.040
If they arrive out of order, which will believe me, they will, because each segment has sequence

10:30.040 --> 10:33.100
one and segment two has sequence two.

10:33.370 --> 10:34.610
Segment three has sequence three.

10:34.660 --> 10:34.990
Right.

10:35.710 --> 10:38.050
They are shoved into our into an IP.

10:38.050 --> 10:41.920
Beckett IP package has no guaranteed delivery.

10:42.520 --> 10:50.350
It doesn't have a fixed path because each path will might go to this router and thereafter decide,

10:50.350 --> 10:53.770
oh, this path is a little bit busy and congested limit.

10:54.700 --> 10:56.380
Will it send it this route?

10:56.800 --> 10:58.780
So IP packets are disrupted.

10:59.260 --> 11:01.340
They don't know what's the content of this IBM.

11:01.490 --> 11:02.260
They don't care.

11:02.890 --> 11:03.160
Right.

11:03.370 --> 11:09.540
So the IP packets, while they will take certain path of the destination and server, all the same,

11:09.880 --> 11:12.130
they will take almost the same path.

11:12.550 --> 11:16.990
And don't don't think of a path as if a hard coded that all is the same.

11:16.990 --> 11:17.710
They can change.

11:17.710 --> 11:22.650
But for most scenarios, it's almost it's a it's almost the same path.

11:22.660 --> 11:22.960
Right.

11:24.000 --> 11:28.960
A HTC big action will take a different path based on the source end of the station.

11:29.290 --> 11:37.180
That's why there is another protocol called the Multi Path TCP, which introduces a beautiful idea of

11:37.180 --> 11:41.680
using your wi fi interface and your Ethernet.

11:42.490 --> 11:48.970
You know, if you're a mobile phone, you can use your LTE and your Wi-Fi to establish two CCP connections.

11:49.210 --> 11:55.030
And then you effectively, I guess, multiplex you d multiplex, you take your request and you're sending

11:55.030 --> 11:59.320
them through different connections and then you order them on the back end.

11:59.710 --> 12:03.610
That's probably something I shouldn't have talked about, but I don't want to confuse you.

12:03.610 --> 12:04.750
But this is another thing.

12:04.750 --> 12:05.950
Multiple DCB.

12:06.340 --> 12:08.890
So keep it on your back in your head.

12:08.900 --> 12:10.690
But back to the CCP here.

12:10.990 --> 12:12.940
So TB takes a path now.

12:12.970 --> 12:17.980
But this backend change because the IP packet at the end of the day there is no path right to it.

12:21.060 --> 12:21.900
And the segments.

12:23.330 --> 12:23.630
Yeah.

12:23.630 --> 12:28.490
We talked about I was I was talking about the path because IP packets will arrive out of order because

12:28.490 --> 12:29.720
the path might be different.

12:29.720 --> 12:34.970
You know, one writer can send and then IP packets will be arrived out of order.

12:35.750 --> 12:41.530
But if you unpack, you'll see or segment two, segment three and segment one org and order them or

12:41.540 --> 12:44.660
one, two, three or a segment three, segment two.

12:44.660 --> 12:45.920
But we're doing a segment one.

12:45.950 --> 12:47.750
Oh, I'm sorry.

12:48.050 --> 12:54.640
I can't, I guess, acknowledge this stuff because I didn't know if segment one is missing retransmit

12:54.650 --> 12:54.950
police.

12:55.280 --> 12:56.360
And that's what happens here.

12:56.750 --> 12:59.540
Lost segments are retransmitted.

13:01.660 --> 13:05.560
Powerful stuff here and the power of retransmission.

13:06.430 --> 13:06.820
Right.

13:07.780 --> 13:10.810
Is what makes TCP reliable here.

13:13.090 --> 13:14.200
Multiplexing most of us.

13:14.230 --> 13:15.280
I believe we talked about this.

13:15.310 --> 13:21.400
This is a identical slide really from the udp slide as ip targets.

13:21.400 --> 13:27.760
Host only we talk about the host runs many apps and to identify an app you need a port that consumable

13:27.760 --> 13:36.610
port and receiver so the sender multiplexes all the app and to the TCP connections and then all of those

13:36.610 --> 13:40.030
are then the multiplex back to its apps.

13:40.030 --> 13:40.300
Right.

13:40.570 --> 13:44.020
And this is done by the pair of four that we talked about.

13:44.230 --> 13:47.640
Now the operating system will have to define okay, do we have a connection?

13:47.650 --> 13:48.850
Will not deliver immediately.

13:48.850 --> 13:51.040
It will only deliver if there is a connection.

13:51.520 --> 13:59.140
If there is not a connection, then we drop it and sometimes the app will close and shut down without

13:59.140 --> 14:00.400
cleanly close the connection.

14:00.400 --> 14:06.040
And that can cause leakage and stuff that is really unpredictable, nasty stuff, may I say?

14:06.880 --> 14:07.770
And yet again.

14:09.700 --> 14:10.690
I was covering that.

14:10.960 --> 14:13.240
So it's just AP zap.

14:13.240 --> 14:14.140
Why ABC?

14:14.410 --> 14:20.590
And I'm going to go I'm going to disappear for a moment because the next slides are really crowded.

14:21.160 --> 14:21.850
All right.

14:21.850 --> 14:24.640
Let's talk about connection establishment, you guys.

14:26.170 --> 14:33.130
App one on ten 001 Want to send data to app x on ten 002?

14:34.570 --> 14:37.540
This is how that connection established or the three way handshake happens.

14:38.840 --> 14:41.980
App one The first thing is since called something called sin.

14:42.670 --> 14:42.970
Right?

14:43.240 --> 14:49.840
So there's a bit in the segment and the header itself says, okay, this is a sin, which means synchronize.

14:50.770 --> 14:51.190
Why?

14:51.220 --> 14:54.910
Because we need to establish a connection so we can agree on the sequences.

14:54.940 --> 14:56.380
I need to know your sequences.

14:56.380 --> 14:59.050
And you need to know my sequences because.

15:00.080 --> 15:01.810
You can send data by that action.

15:01.820 --> 15:02.330
All right.

15:03.110 --> 15:03.950
That's part of it.

15:03.980 --> 15:04.310
Right.

15:05.240 --> 15:09.630
And you can think about this and say, okay, oh, bidirectional.

15:09.710 --> 15:09.960
Right.

15:09.980 --> 15:12.710
What if I want to build a unique directional system?

15:13.160 --> 15:17.970
If you know you have the only directional system, then you know that it's only one way.

15:17.990 --> 15:21.950
The other way won't send you data, so you can lose that if you want.

15:22.160 --> 15:27.620
If you want to build a back end application that doesn't have bi directional, you know, that's just

15:27.620 --> 15:28.880
a force for thought there.

15:29.750 --> 15:33.610
So yeah, it's in the send request on Port 22 of the.

15:33.620 --> 15:34.670
So this is this is it.

15:34.790 --> 15:35.120
Right.

15:35.480 --> 15:39.830
So as such is running on topics here and ten 002.

15:40.070 --> 15:44.180
And then once we do that, we're going to send that.

15:44.780 --> 15:48.950
And the source is Phi Phi Phi Phi, which is that's the port that the app.

15:49.370 --> 15:49.700
Right.

15:49.700 --> 15:55.910
That since it ten 001 is the source IP and then all of a sudden we reach here.

15:56.630 --> 15:58.550
So that's hey, this is this is my sequence.

15:58.550 --> 16:04.040
I start from sequence thousand, for example, and then ten 002 will reply back with something called

16:04.040 --> 16:04.790
Sinovac.

16:05.030 --> 16:07.580
So will send its own sequences.

16:07.730 --> 16:10.070
So I start from sequence 5000.

16:10.610 --> 16:13.520
And all of a sudden you reach here is all right.

16:13.520 --> 16:14.030
Got it.

16:14.340 --> 16:15.320
And then once.

16:16.410 --> 16:21.540
The final one receives, we ask, and that is complete the handshake.

16:22.620 --> 16:26.850
And all of a sudden we end up with a file descriptor right here.

16:28.560 --> 16:34.770
So we end up with a file descriptor right here that says ten 0015555.

16:35.040 --> 16:39.870
The hash is ten 0022222, two, two, two, two.

16:39.900 --> 16:47.040
So therefore, pair that we talked about uniquely identifies this file, this sort of app to want to

16:47.040 --> 16:52.520
send data to the same port on the same machine.

16:52.530 --> 16:54.450
It will error because as who are you?

16:55.200 --> 16:56.570
You're 77128.

16:56.570 --> 16:58.260
I don't have a file descriptor for you.

16:58.800 --> 17:01.170
You need to establish a connection for that app.

17:01.440 --> 17:01.680
All right.

17:03.270 --> 17:06.900
And all of a sudden now we have both side actually you have a file descriptor here.

17:06.900 --> 17:11.220
And if I look at the here and now, you have a connection and that's how you synchronize the numbers.

17:11.520 --> 17:11.760
Right.

17:12.180 --> 17:13.500
And that's part of the state.

17:13.510 --> 17:16.620
You have to see if the numbers the sequence numbers here.

17:16.950 --> 17:21.690
So this is a finite amount of states that you need to store in the server, not just the file, the

17:21.690 --> 17:24.530
scatter, the sequences, the window sizes that we're going to talk about.

17:24.540 --> 17:25.830
So all take memory, right?

17:26.430 --> 17:31.290
And they have to be there and this memory will increase with the number of connections.

17:31.290 --> 17:35.940
So if you have a lot of connections, at the end of the day, your server will have a limit.

17:36.390 --> 17:40.140
I believe WhatsApp, that's the highest I've seen.

17:40.590 --> 17:47.280
WhatsApp can handle up to 3 million VCP connections per server in Mosaic.

17:47.280 --> 17:48.550
How can you go that hard?

17:48.570 --> 17:48.900
I thought.

17:48.900 --> 17:51.420
I thought the port is 65,000.

17:51.840 --> 17:59.070
Well, of course, because that is all of them are going to the same port and all of them to the same

17:59.070 --> 17:59.370
IP.

17:59.370 --> 18:03.860
But they are but they are coming from different IP addresses in different parts.

18:03.870 --> 18:05.910
Of course, you can go unlimited with that one, right?

18:06.330 --> 18:12.360
We'll just just multiply the IP addresses with 65,000 and then how many IP addresses are in the world?

18:12.810 --> 18:13.080
Right.

18:13.080 --> 18:13.740
4 billion.

18:14.220 --> 18:17.400
That there are no limits when it comes to the source and the.

18:18.000 --> 18:20.040
Yeah, you're making both this variable.

18:20.310 --> 18:24.630
So I know that what's reached 3 million and that's pretty much it.

18:24.660 --> 18:32.820
I don't know other public information about how much connections can, can a server handle because there

18:32.820 --> 18:39.450
is a limit at the end of the day after which the hashing that is happening becomes well, the hash is

18:39.450 --> 18:43.470
really fast because you take these numbers and you immediately look up the table, right?

18:43.770 --> 18:46.590
Because it's a big old one, you immediately find the connection.

18:46.890 --> 18:47.730
That's not slow.

18:48.030 --> 18:48.300
All right.

18:51.320 --> 18:55.640
But then the problems like what if if if a connection is destroyed.

18:55.880 --> 18:56.360
Right.

18:56.900 --> 18:59.180
You need to remove that cache.

18:59.180 --> 19:02.330
And the table, the hash table changes sides.

19:02.330 --> 19:08.090
And we know what happened with the hash changes size the hash get screwed set result and it can cause

19:08.090 --> 19:10.790
trouble in certain situations.

19:11.480 --> 19:15.440
But in memory is the limit and CPU is another limit, right?

19:15.440 --> 19:20.920
If you have a lot flooded of connection, the hashing is what the take of the CPU.

19:20.930 --> 19:21.280
Right?

19:21.950 --> 19:27.860
The CPU cycles to hash these four pairs, the four base, the four entries.

19:28.310 --> 19:31.310
That is what basically takes a lot of CPU.

19:31.670 --> 19:39.110
If you're doing it all the time, then it will take CPU and it will take memory because they have finite

19:39.110 --> 19:39.740
amount of memory.

19:39.740 --> 19:45.770
Whatever, two 5G each multiplied by 3 million, you get a ratio limit eventually.

19:47.750 --> 19:55.550
Sending data so now app once and data to app X now well yeah will sending again less right to A to do

19:55.560 --> 20:03.260
a search or remote in doing that we did the bash or we're doing an LZ right now that I have the data

20:03.290 --> 20:08.330
I have the connection I'm just I'm an actual data app one encapsulate the data into segment and send

20:08.330 --> 20:10.640
it so that's the destination for the source port.

20:11.030 --> 20:13.070
And now we get it over here.

20:13.430 --> 20:15.380
That segment is received, right?

20:16.650 --> 20:20.790
The operating system says, okay, do you have a connection with me, sir?

20:21.480 --> 20:22.800
Bom bom bom bom.

20:22.800 --> 20:24.710
Hash bom immediately found it.

20:24.720 --> 20:26.130
Oh, there's your five disruptor.

20:26.340 --> 20:27.510
Yes, you're good.

20:27.900 --> 20:28.830
Let me take the data.

20:28.830 --> 20:29.130
What do you.

20:29.130 --> 20:29.940
What do you want to go?

20:29.940 --> 20:30.550
Where do you want to go?

20:30.690 --> 20:33.060
Oh 22 oh the two is actually app x.

20:33.890 --> 20:35.580
Here's the app.

20:35.580 --> 20:36.510
Excuse your data.

20:36.510 --> 20:39.740
It just sends this and probably sends all the whole thing, right?

20:40.080 --> 20:41.580
Send it to the app x.

20:41.970 --> 20:48.300
An event is triggered and as a search takes over and does the result and effectively responds with the

20:48.780 --> 20:51.840
but before it responds, it actually acknowledges the data.

20:52.100 --> 20:57.660
It says, okay, I acknowledged whatever the sequence number was there and boom, I acknowledge this

20:57.660 --> 21:00.780
data is this is do reply guys.

21:01.350 --> 21:06.600
We acknowledge the recipient of the LSA command in this case the segment and that's pretty much it.

21:07.620 --> 21:10.380
But here's a hint here I want you to think about it.

21:10.560 --> 21:18.030
Can app one send news segment before EC before the EC of the old segment arise?

21:19.660 --> 21:25.150
That's a good question because now I think the command can I send another command before I get back

21:25.300 --> 21:26.860
that the actual server receives it?

21:27.370 --> 21:28.780
Absolutely, you can.

21:29.860 --> 21:31.900
But there is a limit to how much you can send.

21:32.350 --> 21:34.030
You can send as many segments that you want.

21:34.660 --> 21:35.470
But there is a limit.

21:36.430 --> 21:38.410
All that kind of contradicts my statements.

21:38.560 --> 21:40.510
There is a limit, right?

21:41.110 --> 21:44.830
If you send a segment and you have to wait for the attack.

21:45.070 --> 21:47.270
You're paying the roundtrip time here.

21:47.470 --> 21:48.550
It's so slow.

21:48.970 --> 21:50.770
Imagine sending and waiting.

21:50.770 --> 21:51.620
Sending and waiting.

21:51.640 --> 21:52.570
It's a new way to know.

21:52.840 --> 21:55.780
You can send it up.

21:56.200 --> 21:57.770
It's up to the server.

21:57.790 --> 21:59.050
Does it handle it?

21:59.410 --> 22:03.190
And it's up to another one, which is the routers.

22:03.200 --> 22:05.860
Can the routers, the little boxes handle it?

22:06.010 --> 22:07.690
So this is called the flow control.

22:07.960 --> 22:09.550
This is called the congestion, the draw.

22:09.940 --> 22:12.700
And only then you can send as many segments as you want.

22:13.540 --> 22:16.330
And we're going to talk about all of that.

22:16.330 --> 22:17.920
I know I'm jumping the gun a little bit.

22:18.430 --> 22:19.930
There's another important concept.

22:19.930 --> 22:22.900
So sequence one, sequence to sequence three.

22:23.200 --> 22:26.270
So we're sending three segments here in parallel, if you will.

22:26.290 --> 22:26.590
Right.

22:26.860 --> 22:27.640
One, two, three.

22:28.120 --> 22:28.420
Right.

22:28.870 --> 22:31.420
All of these are IP packets at the end of the day.

22:31.420 --> 22:31.660
Right.

22:31.960 --> 22:32.980
They will arrive.

22:33.960 --> 22:34.800
Out of order.

22:34.800 --> 22:36.990
Maybe some of them might fail.

22:37.110 --> 22:38.880
But eventually, I say, all of them are right.

22:39.360 --> 22:39.600
All right.

22:39.870 --> 22:42.720
So this guy gets sequence one, sequence two and six, one, three.

22:43.350 --> 22:44.550
You have a connection, sir.

22:44.570 --> 22:45.120
You're good.

22:45.810 --> 22:52.410
The host here can acknowledge, and the acknowledgement here works by actually specifying what sequence

22:52.410 --> 22:53.340
audio acknowledging.

22:53.880 --> 22:58.980
So if you are acknowledging three, that means you receive two and one and three, right?

22:59.250 --> 23:02.670
If you acknowledge two, that means you receive anything two and one.

23:03.120 --> 23:05.610
If you are congenial, it means you are received only one, right?

23:05.940 --> 23:09.210
So that's how I acknowledge you can acknowledge multiple segments with one act.

23:09.630 --> 23:11.130
Very powerful concept here.

23:11.400 --> 23:15.090
And so acknowledgement is a very important concept.

23:15.090 --> 23:19.440
And you get you noticed that I'm not talking in details here and they're showing you actual numbers

23:19.440 --> 23:23.850
because this is not the purpose of the course, the purpose of the course to then just say the high

23:23.850 --> 23:30.030
level of how things work, you know, and to take us as close as possible to the application here,

23:30.240 --> 23:32.740
not to dive into the weeds of networking.

23:32.760 --> 23:35.490
And I try to, as much as possible, separate that.

23:36.240 --> 23:37.380
I hope I'm doing a good job.

23:37.380 --> 23:38.280
I don't know if I am.

23:38.910 --> 23:41.280
Here's an example where a lost data can happen.

23:42.150 --> 23:49.380
So up once in segment one and two and three, one, two or three, but sigma three is lost or maybe

23:49.380 --> 23:53.910
timed out, maybe stuck in one of the rafters that needed to be get fragmented.

23:53.910 --> 23:54.720
And it's so big.

23:55.740 --> 24:00.050
There are terrorists sent back and ICMP message said, hey is still big, right?

24:00.240 --> 24:01.950
Any reason can go away, right?

24:02.760 --> 24:05.460
So this guy received only sequence one and two.

24:05.910 --> 24:06.330
So what?

24:06.330 --> 24:07.080
It happens.

24:07.080 --> 24:07.460
It does.

24:07.470 --> 24:07.790
Okay.

24:08.250 --> 24:10.110
I receive one and two at the same time.

24:12.200 --> 24:13.610
I'm going to acknowledge, too.

24:13.700 --> 24:14.190
That's it.

24:14.210 --> 24:17.960
So that means two on one was arrived immediately.

24:17.960 --> 24:18.800
The sender will know.

24:19.370 --> 24:20.070
Wait a minute.

24:20.090 --> 24:21.070
What happened to three?

24:21.080 --> 24:22.250
I sent you a three as well.

24:23.150 --> 24:29.300
Was it alright if you didn't, if you didn't receive three, if you only acknowledge one and two of

24:29.300 --> 24:34.190
them is you didn't receive three, I'm going to rescind it and that's part of the retransmission logic.

24:34.430 --> 24:37.970
So you just sent the data that you already sent.

24:38.810 --> 24:44.390
I so that's part of the retransmission to guarantee I'm always going to send it unless I make sure that

24:44.390 --> 24:44.900
you get it.

24:45.440 --> 24:50.690
So segment three are sent again and then once we are, we get it.

24:50.870 --> 24:53.120
We acknowledge three and now boom.

24:53.390 --> 24:56.570
Keep in mind that we always have the file descriptor on both sides.

24:58.520 --> 25:00.150
Or I thought about closing the connection.

25:00.170 --> 25:01.370
This is another concept.

25:01.940 --> 25:03.950
If you open a connection, you have to close it.

25:04.730 --> 25:05.150
Right.

25:05.810 --> 25:08.300
And this is done by a four way handshake, effectively.

25:08.540 --> 25:12.370
And then one can initiate the closing the connection.

25:12.380 --> 25:14.900
One can receive that closing session.

25:14.900 --> 25:15.140
Right.

25:15.620 --> 25:17.840
So you cannot close something that doesn't exist.

25:17.870 --> 25:18.590
Same concept.

25:18.590 --> 25:24.090
So if you send me a friend, I'm going to check if there is a session for you first before closing something

25:24.110 --> 25:24.830
randomly.

25:25.250 --> 25:29.230
And you cannot just forge and close connections that are not yours.

25:29.240 --> 25:29.570
Right?

25:30.290 --> 25:34.460
So here's an attack that can happen here also.

25:34.460 --> 25:35.810
So that that can happen is working.

25:36.860 --> 25:43.850
If I know the source IP address and the source destination and the destination IP address and this destination

25:43.850 --> 25:45.770
port, I can send a fake.

25:46.770 --> 25:54.960
Uh, then request to do to shut down an existing connection for a, for a given IP address.

25:54.980 --> 25:56.400
Right, if you think about it.

25:57.030 --> 26:00.960
Because what will happen is I'm going to forge my IP errors.

26:01.770 --> 26:02.190
Right.

26:02.430 --> 26:03.690
Spoofed, if you will.

26:03.930 --> 26:07.440
Again, it's not easy, but if you can't do that, then the server will check.

26:07.440 --> 26:09.990
Oh, oh, this source IP destination.

26:09.990 --> 26:11.850
I'll be here that matches.

26:12.150 --> 26:18.000
Let me close the connection so you can effectively shut down some other computer connections.

26:18.750 --> 26:21.360
Right, while you're spoofing.

26:21.720 --> 26:21.880
Right.

26:21.990 --> 26:24.120
That's an that's a nasty thing to do.

26:25.440 --> 26:32.790
So I punched in the fin that's how it outdone he's an event to the port destination local all the jazz

26:33.150 --> 26:40.020
and then the server will acknowledge that fin just defend it will acknowledge the fin the server will

26:40.020 --> 26:47.640
acknowledge that fin and immediately after that the server will send its own fin right telling the set

26:47.640 --> 26:53.040
of okay, I'm ready to close telling the client, sorry, I'm ready to close, go ahead and close it.

26:53.310 --> 27:01.020
And then the client when a moment the client receives that since that ach that is when the connection

27:01.020 --> 27:02.010
is completely closed.

27:02.220 --> 27:10.260
So now when the services that final act it just it can destroy the file descriptor unfortunately the

27:10.260 --> 27:17.190
file descriptor for the person who since the fin remains because.

27:18.400 --> 27:22.180
It is remain in a something called time weight state.

27:22.450 --> 27:25.330
If you ever didn't, it's that you going to see all this time waits.

27:25.930 --> 27:32.410
Whoever initiated the connection end up in that time weight state to wait for any old segment that have

27:32.410 --> 27:32.890
been.

27:33.940 --> 27:35.890
Lost and retransmitted.

27:36.980 --> 27:39.980
To arrive and in order to clean it out.

27:40.010 --> 27:41.090
Because you don't want to.

27:41.570 --> 27:42.020
Ah.

27:42.170 --> 27:46.160
We don't want to close and then open and another file descriptor.

27:46.400 --> 27:52.370
And all of a sudden we have, we receive an old segment that belongs to an old session that we killed.

27:53.360 --> 27:54.760
It will be a will.

27:54.770 --> 28:00.140
It will cause corruption and, you know, certain undesirable things.

28:00.620 --> 28:02.510
But that's basically how you close the connection.

28:03.160 --> 28:04.790
ia4 way handshake, Finn.

28:05.360 --> 28:06.860
Ach, then.

28:07.460 --> 28:07.910
Ach.

28:08.810 --> 28:11.150
And this remains the the policy to what?

28:11.150 --> 28:14.090
I mean I believe in it like 4 minutes or whatever.

28:14.390 --> 28:17.810
Uh, it's basically double the maximum segment size.

28:18.050 --> 28:21.200
We got to talk about that in a minute as well, you know, in the future.

28:23.630 --> 28:24.350
Summer.

28:24.350 --> 28:32.510
Read a so-called summary here to summarize the TCP IP so that CCP protocols stand for transmission control

28:32.510 --> 28:38.690
protocol uses the count of ports just like UDP, but gives you flow control, gives you order packets,

28:38.690 --> 28:40.210
give you guaranteed delivery.

28:40.520 --> 28:40.880
Right.

28:40.880 --> 28:43.460
You can you can argue congestion control.

28:43.460 --> 28:48.320
We're going to talk about them in different lectures, but gives you all these nice features.

28:48.320 --> 28:49.280
It's a stateful.

28:49.280 --> 28:50.930
It has a concept of a connection.

28:50.930 --> 28:55.790
So there's a file descriptor on both server and the client that maintains the connection.

28:55.790 --> 28:58.070
That is so it it it lives in memory.

28:58.070 --> 29:01.070
It lives in the Ramos or takes a finite amount of rain and ran.

29:01.310 --> 29:03.050
So there is a little bit of cost for you.

29:03.050 --> 29:06.560
So there is a limit to how much connections you can open at the end of the day.

29:06.950 --> 29:12.680
We talked about how WhatsApp has that limit of 3 million connection, probably that there are multiple

29:13.370 --> 29:15.500
servers that now have exceeded that.

29:15.500 --> 29:21.800
I don't know personally how much is their limit today for a single server, but yeah, this is a very,

29:21.800 --> 29:24.200
very powerful protocol.

29:24.200 --> 29:26.240
TCP transmission control protocol.

29:26.870 --> 29:30.770
How about we jump into it and next dive into the control.

29:31.280 --> 29:35.180
What exactly is the level of control that we can get with?

29:35.180 --> 29:35.720
DCB?

29:36.380 --> 29:37.130
Let's jump into it.
