WEBVTT

00:00.120 --> 00:03.540
Alright guys, Europe is great and all.

00:04.320 --> 00:06.450
But everything has drawbacks.

00:07.770 --> 00:08.880
Everything has a power.

00:09.150 --> 00:14.910
So this lecture we're going to talk about the pros and cons of the UDP protocol.

00:14.940 --> 00:16.420
So UDP is a simple protocol.

00:16.440 --> 00:17.490
That's the process here.

00:17.640 --> 00:20.640
It's a very elegant, simple protocol.

00:21.150 --> 00:25.200
It's does it does exactly what most developers want.

00:25.380 --> 00:31.410
That's why, like, I've seen a lot of applications like gaming application where we want to do multiplayer

00:31.410 --> 00:34.710
gaming, they use UDP is like, Hey, I don't want to all the bells and whistles.

00:34.710 --> 00:38.550
ATC does so much for me like at least congestion controller.

00:39.150 --> 00:42.090
I'm controlling everything on my network.

00:42.510 --> 00:45.540
I know what I'm doing and only if you know what you're doing.

00:45.540 --> 00:49.950
You can use lower level protocols, you know that to do that stuff.

00:50.790 --> 00:53.160
So the simple protocol, it does exactly that.

00:53.400 --> 00:53.460
No.

00:54.210 --> 00:56.460
Hey, data would be corrupted.

00:56.460 --> 00:56.990
I don't care.

00:57.000 --> 00:57.360
It's okay.

00:57.360 --> 00:58.080
I'm going to fix it.

00:58.080 --> 01:01.230
And I can deal with a certain level of corruption.

01:01.620 --> 01:03.210
Let me deal with the corruption.

01:03.390 --> 01:09.040
Don't just rescind my packet, but just because it's corrupted or it's just it's lost.

01:09.060 --> 01:11.820
No, I can deal with certain losses.

01:12.330 --> 01:14.880
Please deliver the packets as fast as possible.

01:14.880 --> 01:18.870
Latency is what matters sometimes in certain applications.

01:19.260 --> 01:21.050
Correctness is also another thing, right?

01:22.410 --> 01:28.980
And this is your job as a back end engineer and a fund manager to decide do you care about correctness

01:29.790 --> 01:34.950
or consistency as the database people call it, or do you care about latency?

01:35.160 --> 01:37.020
There is a slider that you move.

01:37.320 --> 01:42.390
Hey, I am willing to get eventual consistency for those database people.

01:42.390 --> 01:51.570
This is kind of a reference or a rather good performance rather than complete consistency or strong

01:51.570 --> 01:52.320
consistency.

01:52.320 --> 01:52.520
Yeah.

01:52.560 --> 01:54.390
Let me get eventual consistency.

01:54.930 --> 01:55.470
But.

01:56.420 --> 01:56.740
I know.

01:56.750 --> 01:57.630
Rather good performance.

01:57.650 --> 01:58.370
Oh, no.

01:58.640 --> 02:00.410
I am pessimistic.

02:00.890 --> 02:02.720
I have pessimistic concurrency control.

02:03.050 --> 02:11.170
I need full consistency, realizable isolation level, and I need everything to be consistent.

02:11.180 --> 02:14.240
I don't care if it takes a few millisecond extra.

02:14.990 --> 02:16.700
But I am getting correct result.

02:17.240 --> 02:18.170
You can sacrifice.

02:18.170 --> 02:19.070
Sometimes you can.

02:19.070 --> 02:19.820
Sometimes you can't.

02:20.810 --> 02:22.070
So header size is small.

02:22.790 --> 02:23.840
That's why as the results.

02:23.840 --> 02:25.460
So data grams are so small.

02:25.970 --> 02:27.280
Use this list better with others.

02:27.290 --> 02:27.770
All right.

02:27.860 --> 02:28.760
And it's stateless.

02:29.270 --> 02:36.470
The beauty of statelessness is it doesn't occur by memory on the back end.

02:36.470 --> 02:41.000
And the GRONDIN goes stateless that there is no state so scales nicely.

02:41.750 --> 02:47.780
This up while it takes a little bit of motor memory, it adds up and you can run out of these resources.

02:48.050 --> 02:48.380
Right.

02:48.800 --> 02:53.870
If you have so many connections, the grand scheme of things, it's not really a big deal, but everything

02:53.870 --> 02:54.350
adds up.

02:54.530 --> 02:55.250
The end of the day.

02:55.280 --> 02:58.490
So it consumes this memory, the nothing stored in the server or the client.

02:58.490 --> 02:59.230
There's no state.

02:59.240 --> 03:03.140
It is stateless, you know, and low latency.

03:03.380 --> 03:04.250
There's no handshake.

03:05.240 --> 03:08.090
You can literally send the data and immediately reach there.

03:08.900 --> 03:09.950
There is no latency.

03:10.700 --> 03:14.330
You know, there is no prior knowledge communication.

03:14.570 --> 03:15.710
There is no order.

03:16.040 --> 03:16.790
That has to be.

03:17.760 --> 03:18.330
Faust.

03:18.480 --> 03:25.230
You know, there is no sequences that labeled every package or segment is labeled with sequences.

03:25.500 --> 03:30.810
And you have to they they these segments better arrive in order.

03:30.810 --> 03:36.300
If they are not in order, ask the client to rescind it, to retransmit that and acknowledge only that

03:36.750 --> 03:39.710
it is already transmitted and guarantee that it doesn't have any of that.

03:39.720 --> 03:48.180
So yeah, it's not really great when it comes to correctness, but some developer says, hey, I'm okay

03:48.180 --> 03:48.660
with that.

03:49.110 --> 03:51.810
It's I'm building and building a video streaming app.

03:51.810 --> 03:57.420
And and so if some of the frames are dead because I'm going to I'm going to figure out I'm going to

03:57.420 --> 04:02.400
use A.I. to reconstruct the image on the client side, because I can.

04:03.350 --> 04:05.300
You know, speculate how it'll look like.

04:06.380 --> 04:08.840
So latency is low latency is very critical for me.

04:08.990 --> 04:10.490
So pros and cons.

04:11.000 --> 04:12.290
Nothing is perfect.

04:13.680 --> 04:15.060
But now let's talk about the cause.

04:15.060 --> 04:17.730
It's actually the causes, just the flip of the pause.

04:17.730 --> 04:19.560
Fiona one no acknowledgement.

04:19.560 --> 04:22.890
So you really, if you send something, you really don't know if it reaches or not.

04:23.370 --> 04:28.890
And that can be bad in certain situations because you really need to make sure that the message has

04:28.890 --> 04:34.500
arrived, you know, to make it to to to to I need to update certain state and your clients.

04:34.500 --> 04:40.680
I do special for database application you can really use UDP because although otherwise you'll corrupt

04:40.680 --> 04:41.880
your database immediately.

04:41.880 --> 04:42.150
Right.

04:44.580 --> 04:45.990
There's no guarantee delivery.

04:46.620 --> 04:46.980
Right.

04:46.980 --> 04:51.630
I guess that was a pros and it's also I can't zone the there is no guarantee delivery.

04:52.680 --> 04:58.980
If you send something it won't arrive in or arrive in order to be to be specific.

04:58.980 --> 04:59.190
Right.

05:00.180 --> 05:08.850
And if it's no guarantee delivery, then there's going to be a problem because my packets will not arrive.

05:08.850 --> 05:12.870
And if the doesn't arrive, then the server I do.

05:12.870 --> 05:13.710
I have no idea.

05:13.710 --> 05:14.760
First, there is no acknowledgement.

05:14.760 --> 05:21.360
I don't have an idea that the server actually got it and the server state was updated and the database

05:21.360 --> 05:23.850
was in this state or not, I don't know.

05:24.210 --> 05:32.310
And this lack of knowledge is scary sometimes connection less because it's connection less because the

05:32.310 --> 05:34.860
parties are not authenticated per say.

05:35.760 --> 05:37.560
This is like a soft authentication, right?

05:38.460 --> 05:45.120
Anyone can send anything to anyone and that's why UDP is used for attacks, right?

05:46.470 --> 05:55.190
One popular attack is actually a DNS flooding attack where you use it, you flood a server with three

05:55.200 --> 05:56.250
UDP packets and.

05:57.650 --> 05:59.900
The server has to process UDP.

06:00.320 --> 06:00.700
Why?

06:00.740 --> 06:02.420
Because UDP is stateless.

06:03.020 --> 06:04.880
You don't know if this is.

06:05.240 --> 06:06.290
It doesn't check.

06:06.740 --> 06:08.120
Did you talk to me before?

06:08.990 --> 06:10.640
There is no such question.

06:11.900 --> 06:13.400
It just processes everything.

06:13.850 --> 06:14.210
Right.

06:15.440 --> 06:20.840
So you can literally flood a server with UDP packets or detect.

06:20.870 --> 06:21.860
I say packets now.

06:21.950 --> 06:22.840
You get the point, right?

06:23.240 --> 06:28.880
UDP data comes, you can flood a server with data grams and the server better process that.

06:29.210 --> 06:32.030
And it will take finite amount of time to process it.

06:32.030 --> 06:34.190
And as a result, you can dose the server.

06:34.610 --> 06:36.980
You can you can create a denial of service.

06:38.300 --> 06:47.900
Another way some users do that is some attacker, they would say is use a DNS flooding by sending UDP

06:47.900 --> 06:55.340
requests to normal DNS resolvers and forging their source IP, assuming they can write the source IP,

06:55.340 --> 06:58.820
making all the source IP that target the victim.

06:59.510 --> 06:59.870
So.

07:01.070 --> 07:08.630
If all these millions of machines talking to one server and forging all their IP addresses the source

07:08.630 --> 07:09.620
to be their victim.

07:10.070 --> 07:11.390
The DNA sort of cursors.

07:12.600 --> 07:13.670
They are scalable, right?

07:13.980 --> 07:14.820
There are thousands.

07:15.240 --> 07:20.220
They will reply back with a reply to that victim.

07:20.670 --> 07:22.680
And the victim will says What is going on?

07:22.890 --> 07:24.390
Why am I receiving the illness?

07:24.390 --> 07:26.190
Replies I never asked for one.

07:26.820 --> 07:27.140
So.

07:27.140 --> 07:27.970
So you will.

07:28.010 --> 07:28.680
You'll start.

07:29.010 --> 07:30.810
The operating system has to process that.

07:31.110 --> 07:38.250
And when you process this much data, grams yield effectively die and the server shut down.

07:38.490 --> 07:40.830
So yeah, no prior knowledge is actually bad.

07:41.760 --> 07:42.690
No flow control.

07:43.940 --> 07:46.150
No congestion control, no order packets.

07:46.160 --> 07:49.790
All of this are lumped because they are prose of the TCB.

07:51.500 --> 08:01.130
If you send data grams to this data delegate's server, you have no idea of the server can handle their

08:01.130 --> 08:04.520
sets of data crumbs you're sending so you don't have a flow control.

08:04.820 --> 08:05.990
It was like, How much can I send?

08:06.140 --> 08:07.340
Can I said, seven packets?

08:07.370 --> 08:08.840
And I said, 800.

08:09.500 --> 08:11.950
Because I have I can send all day data on one.

08:11.960 --> 08:18.410
But you have no clue whether the target can handle it because you don't know the buffer of that target.

08:18.440 --> 08:22.670
I guess you can build this at the application layer if you want.

08:23.420 --> 08:26.750
You know, and by doing that, you will be a layer for protocol.

08:27.410 --> 08:31.550
Frankly speaking, you know, if you think about it, you will be you will build the flow.

08:31.550 --> 08:37.250
Control in the application itself says, okay, you can let the server responds with an woodpecker that

08:37.250 --> 08:39.080
says, Hey, I can handle thousand bytes.

08:39.470 --> 08:41.030
I can handle 500 K.

08:41.090 --> 08:41.420
Okay.

08:41.420 --> 08:42.450
That's a lot, though.

08:42.530 --> 08:42.770
Yeah.

08:43.610 --> 08:49.640
So you can build that because some people will say that, hey, okay, I don't want full control as

08:49.640 --> 08:50.180
too much.

08:50.600 --> 08:52.490
I'll build my own, you know?

08:54.240 --> 08:59.970
Primitive rock and roll and the sort of will let me know this is how much it handle and can do it.

09:00.330 --> 09:10.020
Yeah, a lot of elite, if you say engineers who build like multiplayer badass game heroes, they do

09:10.020 --> 09:14.130
this, you know, they use the European, they build the features they want on the wall, the simple

09:14.130 --> 09:14.640
protocol.

09:14.910 --> 09:20.970
They don't build everything right because these DCB does a lot and it's good and bad at the same time.

09:21.480 --> 09:25.260
No congestion control right now.

09:25.260 --> 09:30.060
Yeah, we talked about how the server can, can or cannot handle it.

09:30.060 --> 09:31.110
That's the flow control.

09:31.590 --> 09:37.680
How much can the server and the congestion because those like how how much the rotors can handle are

09:37.710 --> 09:40.410
my IP packets are going into the routes.

09:40.650 --> 09:40.980
Right.

09:42.330 --> 09:48.930
It's going through a rout as many, many others night and then more out there is the more latency and

09:48.930 --> 09:51.030
the more congestion it can congest.

09:51.600 --> 09:53.040
UDP doesn't have any of that.

09:53.760 --> 09:56.190
You don't do you don't know if you're congested or not.

09:56.430 --> 09:57.690
Talked about that a little bit, right?

09:58.380 --> 09:59.400
There is none of that.

10:00.120 --> 10:02.340
So and I have no idea how do you build that?

10:03.000 --> 10:10.110
Sometimes you don't care to say I don't want congestion control because you can never congest the network

10:10.110 --> 10:10.590
itself.

10:10.740 --> 10:10.980
Right.

10:11.700 --> 10:14.580
Or authors are protected against congestion.

10:14.580 --> 10:20.190
They will have certain amount of buffer so that you don't basically eat the whole network, no order

10:20.190 --> 10:20.610
packets.

10:21.510 --> 10:28.290
Talking about that and security, it can be easily spoofed because now, since there is no knowledge,

10:28.290 --> 10:30.690
anyone can send a packet to anyone.

10:31.050 --> 10:31.290
Right.

10:32.280 --> 10:32.690
Uh.

10:33.740 --> 10:34.430
You can send that.

10:34.430 --> 10:39.320
You can start sending data to anyone and they will have to, unfortunately, process it.

10:39.620 --> 10:39.950
Right.

10:40.880 --> 10:43.190
And the act of processing it.

10:44.650 --> 10:45.520
Cost.

10:45.610 --> 10:50.980
There is a cost to that and that cost it from the CPU, from the memory.

10:50.980 --> 10:55.330
And as a result, if you do it a lot, you can dose the machine, the denial of service.

10:55.330 --> 10:58.240
That is, you cannot do this with DCP.

10:58.240 --> 11:00.010
You can't spoof DCP, DCP.

11:00.010 --> 11:02.950
There is a prior handshake that is required.

11:03.050 --> 11:05.350
Do the handshake and then let's talk.

11:05.920 --> 11:06.960
If you never talk.

11:07.120 --> 11:10.720
You cannot just send data through the ECB, just like, who are you?

11:10.780 --> 11:11.830
It's like, What do you want?

11:12.010 --> 11:12.880
Leave me alone.

11:13.060 --> 11:13.990
DCB People say that.

11:14.170 --> 11:18.910
So yeah, this is the pros and cons of the UDP and this kind of end the UDP.

11:20.500 --> 11:21.000
Lecture.

11:21.460 --> 11:27.930
Oh, we're going to do a little bit of an exercise where we're going to spin up a UDP server using Node.js.

11:27.960 --> 11:32.620
We're going to spin up a web server using C, and we're going to talk about the different things and

11:32.620 --> 11:35.260
we're going to send some messaging, going to have a little bit of fun.

11:35.650 --> 11:37.180
And after that, we're going to move to GCP.

11:37.330 --> 11:38.110
Let's do it.
