WEBVTT

00:00.330 --> 00:00.710
All right.

00:00.720 --> 00:08.250
Here's one topic we talked about, which is the TCP head of line blocking, guys.

00:08.580 --> 00:09.420
Let's jump into it.

00:09.480 --> 00:13.050
So TCP orders the packets in the order they are sent.

00:13.440 --> 00:13.740
Right.

00:14.040 --> 00:18.840
The segments are not acknowledge or deliver to the app until they are in order.

00:18.900 --> 00:19.230
Right.

00:19.440 --> 00:25.490
So if I sent one, two, three, four and packet one is not received for some reason, two or three

00:25.500 --> 00:32.670
four took a different path through the routers and path, while one took a was unlucky and took through

00:32.880 --> 00:34.680
an author that was congested and was dropped.

00:34.680 --> 00:34.980
Right.

00:35.670 --> 00:39.600
And in this case, two, three, four was arrived, but one didn't.

00:40.140 --> 00:42.090
The application is not identified.

00:42.090 --> 00:45.420
Fight of new data because this is not a complete set.

00:46.050 --> 00:46.710
This is a grade.

00:46.710 --> 00:50.460
We want the A client to rescind the packet one.

00:50.640 --> 00:53.250
Well actually the client will send all of them right.

00:53.250 --> 00:53.850
In this case.

00:53.850 --> 00:54.120
Right.

00:54.360 --> 00:57.630
Unless selective acknowledge them, which is something I'm going to talk about in the future, hopefully

00:57.870 --> 01:00.990
where it says, okay, I received two, two, four, but I didn't receive one.

01:01.320 --> 01:03.810
So the client will know to send only one.

01:03.820 --> 01:05.580
But let's assume it's not there.

01:05.790 --> 01:06.960
So it will send all of them.

01:06.990 --> 01:07.740
So this is great.

01:07.750 --> 01:11.460
But what if I have multiple client using the same connection?

01:11.700 --> 01:12.660
What does that mean?

01:13.230 --> 01:15.120
Multiple client using the same connection.

01:15.660 --> 01:19.800
Well, we have a use case called DB one, actually.

01:21.000 --> 01:21.960
Where we do that.

01:22.320 --> 01:24.440
Here's an example she may request.

01:24.450 --> 01:27.120
May use the same question to send multiple requests, actually.

01:28.220 --> 01:28.470
Right.

01:29.130 --> 01:35.610
If I let's say request one is actually segment one to do right to say the request is really large.

01:35.610 --> 01:36.840
So we need to segment.

01:36.840 --> 01:40.680
So it's actually what more than two K 2000 bytes.

01:40.960 --> 01:41.190
Yeah.

01:41.430 --> 01:43.050
The request to a segment three or four.

01:43.830 --> 01:47.490
So let's say segment two and three and four arrive, but one is lost.

01:47.820 --> 01:54.450
So logically speaking, if you think about it from the application, you as a as a front end injury

01:54.450 --> 01:59.700
in this particular case, this is a request to this is a request one request two is three and four.

01:59.700 --> 02:01.770
Request one is one and two.

02:02.310 --> 02:07.500
So if request two technically arrived successfully, right.

02:08.360 --> 02:10.250
Hey, Fred Ford is right there.

02:10.520 --> 02:13.460
Deliver it, please, to my app so I can respond.

02:13.460 --> 02:15.020
Because these are stateless.

02:15.590 --> 02:16.100
Nope.

02:18.110 --> 02:19.430
The whole thing is blocked.

02:20.800 --> 02:22.330
One is is not arrived.

02:22.570 --> 02:23.680
The whole thing is blocked.

02:23.980 --> 02:27.580
One segment is missing the entire fleet of records.

02:27.610 --> 02:28.910
Imagine ten requests.

02:29.350 --> 02:32.080
It was intended course and the first segment is dead.

02:33.310 --> 02:35.590
Your ten requests will not be delivered.

02:35.600 --> 02:37.060
You will have to rescind all of them.

02:37.300 --> 02:38.860
That is a huge problem.

02:38.860 --> 02:44.290
Initially be on one and specifically to be to actually with streams is to be to use DCP.

02:44.590 --> 02:51.910
And that's one major problems because we use the same TCP connection, right, to send multiple streams

02:51.910 --> 02:52.420
of data.

02:52.750 --> 02:53.110
Right.

02:53.380 --> 02:58.230
And each stream technically is independent from the other stream.

02:58.240 --> 02:58.630
Right.

02:58.870 --> 03:01.750
This is a stream of in think of the request as a stream here.

03:02.260 --> 03:03.910
They are completely independent.

03:03.910 --> 03:11.920
But because DCP is just a blob of streaming data, it doesn't know that it doesn't have that context,

03:11.920 --> 03:12.730
unfortunately.

03:13.120 --> 03:19.690
So as a result, you end up blocking and this is called the TCP IP head of line blocking.

03:20.080 --> 03:26.410
And this is one of the major problems that SDB too has, which was solved with STB three and quite effectively.

03:26.650 --> 03:29.950
So obviously this introduced a huge latency in apps, right?

03:29.960 --> 03:35.490
When you do STV two, right, especially if you send a lot of requests, you you're going to feel it

03:35.500 --> 03:44.620
if there are some packets that are, you know, dropped or felt congestion or, or any other reason.

03:45.400 --> 03:50.320
You mean like innovative it and that's basically it, guys, right?

03:50.680 --> 03:55.360
This is the head of line blocking problem.

03:56.020 --> 04:00.730
Obviously, I'm going to talk about Quakecon in a different video probably, but this is it.
