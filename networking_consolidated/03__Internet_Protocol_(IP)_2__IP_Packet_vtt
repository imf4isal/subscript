WEBVTT

00:00.060 --> 00:06.720
Now that we have discussed the building blocks of the Internet protocol itself, I'd like to go and

00:06.720 --> 00:08.700
take a moment to.

00:10.010 --> 00:16.400
Take the lid off of this and dive into the IP packet itself.

00:16.850 --> 00:21.080
This is the anatomy of the IP packet as jump into it.

00:21.320 --> 00:27.320
I'll write the IP packet, the anatomy of the IP packet itself.

00:27.620 --> 00:30.380
You know, we're now we're going a little bit deeper.

00:30.590 --> 00:37.580
We've always as back end engineers and funded engineers, we always look at the IP packet as just a

00:37.580 --> 00:44.570
bunch of data with a targeted IP address and a source IP address, as at least I always visualize it

00:44.570 --> 00:48.680
this way, but it's critical to understand certain pieces.

00:48.680 --> 00:49.880
Not all, really.

00:50.180 --> 00:55.160
What I believe there are certain important information about the IP back itself, and this is what this

00:55.160 --> 00:55.790
lecture is about.

00:56.360 --> 00:58.370
So what does IP but IP recognize?

00:58.370 --> 01:00.800
Headers and data sections.

01:01.220 --> 01:02.840
Two sections, the data and the header.

01:03.170 --> 01:05.050
Most of the time we really care about the data.

01:05.060 --> 01:06.410
We don't really care about the headers.

01:06.800 --> 01:16.490
But if you want to debug certain problems or understand certain situations, you need to dive into this

01:16.490 --> 01:16.790
thing.

01:17.720 --> 01:23.300
One more important thing to understand is the size of the packet and headers come into the picture.

01:23.330 --> 01:26.660
If you add a 20 extra byte, that's the IP here, by the way.

01:27.110 --> 01:30.890
20 byte extra to your data.

01:30.920 --> 01:34.340
That is a 20 by that you that's not really your data.

01:34.340 --> 01:37.850
It's it's the cost of doing business effectively.

01:38.390 --> 01:38.960
And guess what?

01:39.380 --> 01:43.820
This can go up to 60 bytes if there are certain options are enabled.

01:43.820 --> 01:47.030
So I believe those options are not always in.

01:47.160 --> 01:52.820
But if they are, you can go up to 60 bar it's forces to back it.

01:52.820 --> 02:00.920
So it is really important for these certain algorithms to kick in to save on sending like a single bite

02:01.220 --> 02:05.030
of packet, you know, with 20 header, 20 bytes header.

02:05.030 --> 02:10.490
It's just a waste of time, you know, it's just a waste of resources to send a single wide and then

02:10.490 --> 02:13.460
attach a 20 byte header to it.

02:13.460 --> 02:15.980
So that's what algorithm like.

02:15.980 --> 02:21.920
Nigel Algorithm and delayed acknowledgement try to solve effectively, you know, try not to send your

02:21.920 --> 02:26.300
else command through search as a single back is just a waste, you know.

02:26.570 --> 02:29.150
But sometimes you can escape that, you know.

02:29.480 --> 02:38.660
That's why we have the data section can go up to 65, 536, you know, and that's because the length

02:38.660 --> 02:40.820
of the data itself is as 16 bit.

02:40.880 --> 02:47.150
So you can only address up to 16 bit worth of content that's equal to the equivalent to 65,000.

02:47.150 --> 02:55.040
And to be honest, I never seen an IP packet that large at all because if you think about it right,

02:55.040 --> 03:01.040
and we're going to talk about this in later sections, there is something called the empty you name,

03:01.520 --> 03:03.290
which is the maximum transmission unit.

03:04.070 --> 03:07.040
So next transmission within the Internet is 1500.

03:07.460 --> 03:16.250
So what packet and avoid all the ideas or fragmentations you can't really shove more than 1500 words

03:16.250 --> 03:18.320
around IP packet without a fragmentation.

03:18.320 --> 03:24.920
So seeing that maybe in a cloud and Amazon where is that custom made hardware with empty you is I don't

03:24.920 --> 03:33.080
know a gigabyte gigabit empty use that I don't know if that's even possible but that will reach that

03:33.080 --> 03:42.080
but to me you will never reach that in single IP packets is almost the average is 1500 bytes, maybe

03:42.080 --> 03:45.410
9000 certain situation, but that's sort of in jumble friends.

03:45.410 --> 03:46.610
Well, that's a bit premature.

03:47.030 --> 03:51.200
So yeah, I always like to add this IP packet to a back end engineer.

03:51.950 --> 03:54.380
It's a bunch of data destination IP address.

03:54.560 --> 04:01.010
So as IP areas, I for the longest time I always look at the IP back in like this now and effectively

04:01.010 --> 04:05.780
like this the right hand side has the destination and the left hand side is the source IP address.

04:06.110 --> 04:08.360
It doesn't look like this on.

04:09.330 --> 04:10.230
On paper.

04:10.510 --> 04:10.770
Right.

04:10.780 --> 04:17.440
But I personally like to do it this way because it fits like I met through a Scud doll, if you will.

04:17.460 --> 04:23.110
You know, I packets, vitamins, our frame, the segment fits into the data and so on.

04:23.110 --> 04:23.310
Right.

04:23.580 --> 04:24.210
I just like it.

04:24.210 --> 04:24.930
Do it this way.

04:25.170 --> 04:29.670
But here is how the actual IP packet looked like.

04:30.120 --> 04:31.440
Scary, isn't it?

04:31.770 --> 04:36.900
So this is how it actually looks like, you know, the IP packet itself and these are the references

04:36.900 --> 04:42.290
you can use that at this DA of C of the IP protocol, you know, that are broken.

04:42.300 --> 04:47.250
This is the Wikipedia that explains, you know, have a summary of all that stuff.

04:47.880 --> 04:49.140
What are we looking at here?

04:50.310 --> 04:59.100
This is, you know, horizontally from 0 to 31 is that is is four bytes, you know, so this is a bits

04:59.100 --> 05:01.110
a bits, Airbus air bits.

05:01.560 --> 05:03.690
You know, this is how it's organized.

05:03.810 --> 05:10.530
So four bytes and the first all four bytes and the second row for Biden, the third row for Biden in

05:10.540 --> 05:13.920
the fifth row and for Biden on the final one.

05:13.920 --> 05:21.480
So if you multiply by four by five rows, that gives you 20 bytes that we talked about.

05:21.600 --> 05:24.840
So this is the options and this is determined by the Internet headline.

05:24.850 --> 05:26.040
We're going to talk about it in a minute.

05:26.520 --> 05:31.410
By default, this is five which which explains these five bytes, you know, by four rows.

05:31.650 --> 05:36.270
And if it goes more than that, then that will define the length of the options effectively.

05:36.390 --> 05:38.370
And this goes up to 60 now.

05:38.370 --> 05:42.030
We'll get to talk about it so we can add stuff to these options.

05:42.030 --> 05:43.200
You know, and this is good.

05:43.950 --> 05:50.760
Those guys, whoever it to find the IP protocol, they defined it in a way to make it extensible.

05:51.150 --> 05:57.390
Unfortunately, from what I read is some writers effectively block the options for some reason, you

05:57.390 --> 05:59.790
know, because it's dangerous or whatever.

06:00.090 --> 06:02.280
So this is sometimes getting blocked.

06:02.280 --> 06:05.160
You know, that's the sad thing about the Internet.

06:05.190 --> 06:10.020
Not everybody follows the rules and as a result, you don't get predictable.

06:10.020 --> 06:16.950
So otherwise I go back in and I would have definitely use the IP packet to, to sneak in data, my own

06:16.950 --> 06:18.390
data in the packet itself.

06:19.020 --> 06:20.640
Imagine that how cool this is.

06:20.940 --> 06:27.830
You know, we always build on top of, you know, protocols on top of TCB, on top of DB to we build

06:27.840 --> 06:32.760
protocols on top of protocols and we forget how that this is available for us.

06:32.970 --> 06:38.670
You know, as programmers we can write a packet and we can send options, right?

06:39.160 --> 06:39.930
Unfortunately.

06:40.240 --> 06:43.560
What do you guarantee that these options are arrived safely?

06:44.280 --> 06:44.790
I don't know.

06:44.790 --> 06:46.040
Apparently not.

06:46.050 --> 06:48.930
You know, because these options sometimes are dropped.

06:49.110 --> 06:52.380
But it's pretty cool if you think about it.

06:53.040 --> 06:58.320
I don't know if these are user said or not, but regardless, this is the data portion we talked about.

06:58.320 --> 07:03.300
This goes up to 65 kilobytes, you know, 64 kilobytes to be specific.

07:03.930 --> 07:06.450
Know and let's go through this version.

07:07.260 --> 07:09.960
What's the version of this is either four or six?

07:09.960 --> 07:12.300
We don't have are versions of the IP protocol, right.

07:12.750 --> 07:15.150
So this is either for a specific bed.

07:15.150 --> 07:21.720
So we have zero one, two, three, you have four bits to describe that little bit of an overkill if

07:21.720 --> 07:22.410
you think about it.

07:22.410 --> 07:22.650
Right.

07:22.830 --> 07:23.340
Four bits.

07:23.480 --> 07:26.010
How much is that is that's 16 numbers.

07:26.250 --> 07:26.580
Right.

07:27.000 --> 07:27.630
Because to the bar.

07:27.630 --> 07:28.050
Eight.

07:28.290 --> 07:29.430
Exactly, 15.

07:29.890 --> 07:30.240
Right.

07:31.200 --> 07:31.980
That's a lot.

07:32.610 --> 07:37.530
So they embedded like hey, we will go up to version 15 of the IP protocol.

07:37.890 --> 07:45.060
But sadly these bits are never used, you know, because we only use for our six and now so we never

07:45.290 --> 07:46.260
lose the other bits.

07:46.260 --> 07:48.690
So it's a waste, but that's what we have today.

07:50.400 --> 07:51.450
Internet header length.

07:51.450 --> 07:52.230
We talked about this.

07:52.230 --> 07:57.150
This defines how long is the options and by default IDL is five I believe.

07:57.300 --> 07:57.630
Right.

07:57.930 --> 08:01.830
And you can add more say okay, I need 20 bytes.

08:01.840 --> 08:02.190
Right.

08:02.430 --> 08:07.830
Of options and that will in there will allow the router to read the options or not.

08:07.830 --> 08:15.600
If this is five, it will read one, two, three, four, five will read this five rows if you will.

08:15.600 --> 08:16.620
And the total length.

08:17.190 --> 08:17.490
Right.

08:17.760 --> 08:21.060
This describes the total long of the whole thing.

08:21.060 --> 08:23.130
You know, this includes the data and the header.

08:23.550 --> 08:27.210
So and this is extreme, but as we talked about, so eight plus eight.

08:27.780 --> 08:37.530
So you can go up to two to the power, uh, 16, which gives you the 65,000 bytes and that describes

08:37.530 --> 08:40.920
not just the data just above the whole header which is could be 20.

08:41.370 --> 08:46.620
You know, I do the, do the math 22 up to 60 based on the options if you have options there.

08:46.980 --> 08:53.700
But yeah, fragmentation, this is really a powerful concept.

08:54.390 --> 08:58.200
Sadly, this is very hard to get right.

08:58.560 --> 09:07.500
And from what I know, most implementations actually uh uh, are frowned upon.

09:07.500 --> 09:08.750
Fragmentation quick.

09:08.870 --> 09:16.940
Give us a good example at a quick every packet and quick the protocol, you know, disables IP fragmentation

09:16.940 --> 09:22.620
because it causes so all sorts of things, you know, because now if the packet is so large, what is

09:22.620 --> 09:22.660
the.

09:22.670 --> 09:24.410
Well, let's talk about the fragmentation really.

09:25.010 --> 09:26.120
We talked about empty.

09:26.120 --> 09:28.460
You write the the maximum transmission unit.

09:28.550 --> 09:28.850
Yeah.

09:29.510 --> 09:32.020
And you don't really need this.

09:32.020 --> 09:33.290
So again, talk about it right here.

09:33.890 --> 09:38.330
So we talk about them to you write the maximum transmission unit, which is the frame size.

09:38.990 --> 09:42.200
And we talked about the IP packet by default.

09:42.200 --> 09:46.550
The IP affected IP package should fit nicely into a single frame.

09:48.150 --> 09:54.750
And if it doesn't fit, that means if the IP packet is large for some reason, let's say the empty was

09:54.750 --> 09:58.560
1500 and the IP Beckett is 2000.

09:59.580 --> 10:01.440
Then that is called.

10:02.830 --> 10:03.810
You have two options here.

10:04.590 --> 10:06.510
The IP package won't fit in the frame.

10:06.630 --> 10:07.350
You have two options.

10:08.070 --> 10:10.890
You can either tell the client whoever sent this Beckett.

10:11.250 --> 10:13.530
Hey, MTU you two too small.

10:13.530 --> 10:16.440
I can fit this large packet that you sent in.

10:16.440 --> 10:19.050
In that empty you fail.

10:19.320 --> 10:20.610
It will send a message.

10:21.030 --> 10:22.140
How does it send a message?

10:22.170 --> 10:23.880
We talked about the ICMP protocol.

10:23.880 --> 10:29.340
That Internet controller message protocol messages are sent through this protocol ping trace allowed

10:29.340 --> 10:35.370
things like that through the IP vehicle will say, Hey, I can throw this back at a still large write.

10:36.300 --> 10:39.570
That is only if you said that don't fragment bit but.

10:40.720 --> 10:41.770
The other option is.

10:44.460 --> 10:44.970
Fragment.

10:44.970 --> 10:45.360
This thing.

10:45.780 --> 10:46.600
The IP packet.

10:47.160 --> 10:47.850
2000.

10:47.970 --> 10:52.470
All right, let's put 101 frame and the 500 goes to another frame.

10:52.470 --> 10:57.870
So you have one IP packet that had been fragmented into two frames.

10:58.320 --> 11:01.200
So those frames will be sent as two frames.

11:01.290 --> 11:05.130
So one packet two frames, the two frames will arrive.

11:05.250 --> 11:05.730
Guess what?

11:05.760 --> 11:06.090
None.

11:06.180 --> 11:07.380
Not necessarily in order.

11:07.590 --> 11:13.500
So the host has to understand that this frame belongs to a something that was fragmented and tried to

11:13.500 --> 11:14.070
assemble.

11:14.070 --> 11:17.490
So there is assemblage that needs to require assembly.

11:17.490 --> 11:19.800
The fragment is one of the most dangerous things.

11:20.280 --> 11:20.640
Right.

11:20.640 --> 11:21.600
Security wise.

11:22.380 --> 11:29.790
And just because people can fake fragmentation, you know, and then I won't go into details on this,

11:29.790 --> 11:33.630
but plus it's its cost that is on the whole site.

11:33.990 --> 11:36.780
So you can fragment if you want.

11:37.140 --> 11:37.380
Right.

11:37.380 --> 11:38.370
And this is how you do it.

11:38.370 --> 11:39.240
We're going to talk about it.

11:39.480 --> 11:46.050
But if you do understand the consequences, one frame might fail.

11:46.050 --> 11:47.220
You have to rescind it.

11:47.220 --> 11:49.680
And how do you send just part of the fragment?

11:50.460 --> 11:51.630
It's very complicated.

11:51.650 --> 11:54.360
And that's why the protection you know what?

11:55.140 --> 11:56.460
Let's not let's not fragment.

11:56.460 --> 11:56.910
Let's not.

11:57.600 --> 12:01.800
Hey, if you don't fit into our frame, just fail.

12:01.950 --> 12:09.000
So that's the responsibility of the client to send back it, that they know this should fit and all

12:09.000 --> 12:11.770
the empty use that the network will pass through.

12:12.510 --> 12:13.290
Back to the slides.

12:15.950 --> 12:17.330
Well, actually, I kind of like this, huh?

12:17.510 --> 12:19.820
Yeah, because there's nothing here, so.

12:19.820 --> 12:21.800
Yeah, well, the ID.

12:22.190 --> 12:24.050
This is the idea of the fragment.

12:24.050 --> 12:26.680
So if you have one packet that a fragment into four.

12:26.780 --> 12:33.410
So this is one, two, three, four, effectively write the ID of the frame flags like, hey, should

12:33.410 --> 12:35.930
I fragment or should I not fragment?

12:36.350 --> 12:42.470
So this is a flag that literally tells the client whether they're out there or not.

12:43.310 --> 12:49.970
Am I supposed to break this big packet if the empty is too small or not?

12:50.330 --> 12:56.270
So if there is a def, I believe here a flag will say, okay, you can, you can, you can fragment.

12:56.270 --> 13:04.460
The fragmented offset is that 0123 and this is ID, which is the unique identifier of the fragment itself

13:04.580 --> 13:04.880
now.

13:05.600 --> 13:11.390
So the all of these are just usually for a for far off fragmentation jumbo packages.

13:11.720 --> 13:13.470
You can get into this as well, right?

13:13.640 --> 13:17.390
If you have that large IP back, it's effectively time to live.

13:17.390 --> 13:18.830
We're going to talk about this as well.

13:18.860 --> 13:19.130
Right.

13:19.820 --> 13:28.340
Every IP packet has a bit actually eight bits, you know, a single byte that represent a counter.

13:30.540 --> 13:32.040
And this is very interesting.

13:32.340 --> 13:38.670
Before we talk about time to live, we're going to talk about a problem because what do we do in this

13:38.670 --> 13:38.930
course?

13:38.930 --> 13:41.490
We we always ask the question of why?

13:41.520 --> 13:42.900
Why does something exist?

13:43.470 --> 13:46.260
Why do we need to fragment back, as do a lot?

13:46.290 --> 13:47.610
Why do we have time to live?

13:48.720 --> 13:52.230
Because of the idea of routing that we talked about in a while.

13:53.340 --> 13:56.730
The packet can go into different routes.

13:56.760 --> 13:57.060
Right.

13:57.480 --> 14:01.470
And they can end up into a situation where they will go into an infinite loop.

14:01.710 --> 14:04.830
We go to this road, this road, and the cities are out there and there's road.

14:04.830 --> 14:06.090
And then back to the same rather.

14:06.720 --> 14:09.570
And the packet can go infinitely.

14:10.110 --> 14:14.880
And you have no idea if you visit this because the routers are not stateful, you know, they don't

14:14.880 --> 14:16.050
save the state.

14:16.050 --> 14:22.200
IP protocol is stateless, you know, they don't save the state of that protocol.

14:22.380 --> 14:28.980
Like, Oh, this package was visited before, unlike the layer layer for where we have states, we have

14:28.980 --> 14:30.240
session, we have all that stuff.

14:30.240 --> 14:34.560
IP is just stateless, no IP packets just passing through, so we don't know.

14:34.560 --> 14:40.830
State So how do I prevent packets from roaming around the internet forever?

14:41.550 --> 14:50.190
Me Time to live TTL You When you send a packet you say, okay, I estimate that this package will live

14:50.190 --> 14:51.960
for 100 routes.

14:52.440 --> 14:54.030
All right, so we put 100 year.

14:55.730 --> 14:56.900
As they go.

14:58.430 --> 15:02.780
This packet goes from you, it reaches the host.

15:02.990 --> 15:06.620
You know that gateway, of course, if you're sending it to the Internet, will go to your gateway,

15:06.620 --> 15:07.370
which is your router.

15:08.180 --> 15:10.580
The router will do minus one to the packet.

15:10.580 --> 15:18.110
So well that the IP packet arrival, the physical layer will be converted to a data link or be converted

15:18.110 --> 15:21.710
to frame the frames right will be converted to them.

15:21.710 --> 15:25.820
IP packets, you know one frame, let's assume simplicity.

15:25.820 --> 15:29.010
One frame goes into a single IP packet, that's biscuits.

15:29.030 --> 15:29.450
In audio.

15:29.810 --> 15:32.330
We have the IP packet and the router takes that.

15:32.330 --> 15:36.530
I'll be back and take the time to live decrement by one and send it again.

15:36.710 --> 15:43.640
So it goes back to the RSA model and goes off to the internet and every one of the writers and hosts

15:43.640 --> 15:48.530
that sees this packet decrements it, that's the responsibility, that's the whole contract.

15:48.890 --> 15:55.850
This way we kind of add the state right to the packet, you know, if have your program before the,

15:55.850 --> 16:01.280
you know, the cons of stateless versus def or stateless, we have to send that information with that

16:02.300 --> 16:04.600
with the request right there.

16:04.610 --> 16:05.990
Of course, in this case the IP packet.

16:05.990 --> 16:07.430
Right, send it with it.

16:07.430 --> 16:12.440
So the state always follows the data itself now and instead of saving it in the host.

16:12.440 --> 16:12.740
Right.

16:13.400 --> 16:22.100
So now if this time to have reached zero, whoever they come into the to zero must stop, you know,

16:23.210 --> 16:29.540
must drop the packet and must send back and ICM P message ICMP shows again.

16:29.570 --> 16:31.640
That's why I explained it very critical.

16:31.910 --> 16:38.720
The ICMP protocol shows up again so they a packet timeout, whatever.

16:38.960 --> 16:44.150
No, I don't remember that exact message and we'll say it, we'll send it back to whomever.

16:45.380 --> 16:47.480
Was that the source IP address.

16:47.990 --> 16:50.300
And that is exactly how traceroute works.

16:50.870 --> 16:52.970
Throw out works or router route.

16:53.600 --> 16:54.080
Same thing.

16:54.920 --> 17:00.620
Trace it out or traceroute you know I believe the the British call the router.

17:00.860 --> 17:01.220
Yeah.

17:01.220 --> 17:05.390
So routers you know the routers right.

17:05.600 --> 17:07.460
Will decrement that until it reaches zero.

17:07.460 --> 17:10.970
And there's a message to the sources said hey there's done.

17:11.150 --> 17:13.310
So the trace road actually does it this way.

17:13.340 --> 17:17.090
It will set a very small time to live and it will incremented.

17:17.450 --> 17:22.250
And every time we pass a hop, we reach the next hop.

17:22.760 --> 17:26.870
That router will tell us about its source IP address.

17:27.050 --> 17:30.170
So we know effectively we trace the entire road.

17:30.590 --> 17:35.120
Obviously some routers disable ICMP altogether, some firewalls disable ICMP.

17:35.540 --> 17:39.590
And if that is the case, that's where you get the dot, dot, dot, dot and trace it out.

17:39.860 --> 17:43.100
You cannot to basically trace it in that particular case.

17:43.730 --> 17:46.460
So that's down to that very, very important concept.

17:46.670 --> 17:49.010
How many hops can this packet survive?

17:49.310 --> 17:52.310
And this is usually 128 number or whatever.

17:52.550 --> 17:58.640
You set it as a large number, not too large, because eventually the packet will live for a long time.

17:58.640 --> 18:02.240
No, I believe that whatever the default number is enough.

18:02.390 --> 18:10.760
If you see your packet takes more, maybe longer path and they are dying, maybe the client will increase

18:10.760 --> 18:16.070
that number protocol and we they of saying what we we know we are in the IP address.

18:17.330 --> 18:22.100
No this is the protocol of what is the content that is inside this data.

18:22.220 --> 18:28.970
Now I always find this when I first saw this is like why that's kind of moot.

18:29.990 --> 18:33.380
I have to define the protocol and you have to know my protocol.

18:33.770 --> 18:35.300
I want to send the strand of data.

18:35.300 --> 18:36.740
Doesn't have to be a protocol.

18:36.950 --> 18:38.310
I want to invent my own protocol.

18:38.310 --> 18:41.210
Are you going to block me then?

18:41.660 --> 18:43.820
I thought about this, right?

18:44.150 --> 18:47.750
I say, Hey, just read the data and figure out the protocol.

18:47.930 --> 18:49.340
That's why that's what.

18:49.520 --> 18:51.500
That's the first thought that came to my mind.

18:51.710 --> 18:56.510
Why do you need an extra eight bits waste, you know?

18:57.140 --> 18:58.270
And then I thought about this.

18:58.880 --> 18:59.510
You know what?

19:00.740 --> 19:01.880
It's actually a good idea.

19:02.360 --> 19:05.990
This way the Raptors don't have to pass the entire data.

19:06.260 --> 19:13.190
They can just read that 20 bytes header and immediately figure out what is inside this and whether they

19:13.190 --> 19:15.350
should pull the data or not.

19:15.650 --> 19:18.140
You know, that's ingenious effectively.

19:18.290 --> 19:19.640
We always do this.

19:19.730 --> 19:27.890
You know, this method takes animated data to save performance and obviously it's probably decided to

19:27.890 --> 19:30.250
block or want to do anything else.

19:30.260 --> 19:31.460
You can just read this protocol.

19:31.820 --> 19:38.330
So our protocol could be ICMP is part of a would that it does this DCP or other UDP whatever the content

19:38.330 --> 19:40.700
of the IP, the IP data itself.

19:41.120 --> 19:42.290
That's the protocol here.

19:42.320 --> 19:44.810
There's a list and and Wikipedia.

19:44.840 --> 19:51.130
But if I can share it as well, showing you over a single protocol that for example, unspecified,

19:51.380 --> 19:54.560
I think that is like miscellaneous or something like that.

19:54.560 --> 19:56.090
You can put all that stuff here.

19:56.210 --> 19:58.520
There's there's obviously a big eight bit.

19:58.520 --> 19:59.420
So how many do we have?

19:59.750 --> 20:04.190
You can have up to 255 protocols, but that's it.

20:05.870 --> 20:07.280
Source on destination IP.

20:07.670 --> 20:12.140
By far the most important pieces of metadata here to the header.

20:12.590 --> 20:15.290
Where are you going and where are you coming from?

20:15.560 --> 20:17.600
Very important piece of information.

20:18.020 --> 20:22.310
Everybody can fake source IP errors, you know, you can try.

20:22.340 --> 20:26.510
That's why it's like, okay, all my IP address has been spoofed.

20:27.050 --> 20:32.050
You know, I hear a lot of people, it's like it's like, oh, this is not this.

20:32.750 --> 20:35.000
We've seen your IP address on our forums.

20:36.410 --> 20:38.220
No, that was not me.

20:38.240 --> 20:40.160
My IP address was spoofed.

20:40.850 --> 20:41.570
I was like, Yeah.

20:41.600 --> 20:44.090
Like, spoofing is something easy to do, huh?

20:45.200 --> 20:47.860
Spoofing is the idea of changing the source.

20:47.900 --> 20:54.530
Every packet that you send right from your machine, you effectively change the source IP address to

20:54.530 --> 20:55.280
be something else.

20:55.640 --> 20:56.860
You can do that, right?

20:57.290 --> 20:58.280
But guess what?

20:58.700 --> 21:02.510
Your ISP, the packet, the IP will go through the browser.

21:02.510 --> 21:05.060
Then the first router, it hits the major router.

21:05.060 --> 21:06.710
What is what's what's the first major?

21:06.710 --> 21:13.790
Rather it's your ISP because that's your link to the internet and it will say say hey, my source IP

21:13.790 --> 21:19.560
address actually whatever that guy, you know, you can put any number you want, you can you can write

21:19.560 --> 21:20.990
that simple code that do that.

21:20.990 --> 21:23.980
Does that rewrite every single IP packet?

21:24.680 --> 21:25.000
Right.

21:25.220 --> 21:30.740
The source IP would be something else, but your ISP, ISP will call you out like, wait a minute,

21:30.800 --> 21:32.300
that's not your source IP address.

21:32.330 --> 21:34.310
I know your IP address.

21:34.340 --> 21:35.630
I assigned it to you.

21:35.990 --> 21:37.760
So your ISP actually blocks it?

21:38.300 --> 21:40.960
No, you cannot do that unless.

21:41.310 --> 21:45.470
Unless every single Internet provider will have this block.

21:45.470 --> 21:47.060
You know, you cannot spoof anymore.

21:47.060 --> 21:53.000
You know, it's not easy to spoof IP addresses, you know, unless you build your own ISP, which is

21:53.000 --> 21:54.320
I don't think it's impossible.

21:54.320 --> 21:55.040
You can do it.

21:55.160 --> 22:00.470
And then you run your own Espoo, pay money to link yourself to the internet.

22:00.470 --> 22:02.120
Yeah, you can spoof all you want that.

22:02.540 --> 22:06.800
But even if you spoof, then how, how would you get responses back?

22:06.800 --> 22:10.280
Because that's what is used to the responses, you know.

22:11.390 --> 22:17.240
So yeah this the nation IP is where are you going source is where you're coming from very critical and

22:17.240 --> 22:24.500
these are, as we talked about four bytes because this is what this is the IPV four write explicit congestion

22:24.500 --> 22:25.040
notification.

22:25.040 --> 22:28.700
We're going to talk a bit about this more on the TCP IP section.

22:29.270 --> 22:35.990
But this bit is effectively is is from an A, so from a lower layer upon layer from an upper layer.

22:36.230 --> 22:45.440
This bit is set by that outer and this is what it means, explicit congestion notification before we

22:45.440 --> 22:47.930
talk about acceptable congestion notification.

22:49.840 --> 22:53.960
And again, we're talking about this in details and the future, but it doesn't hurt to talk about it.

22:54.130 --> 23:01.170
Now, congestion is when packets start to drop you.

23:02.080 --> 23:05.530
I.B. packets will be arrived at routers like floods.

23:05.530 --> 23:07.610
You know, everybody sending data.

23:07.630 --> 23:10.180
Everybody I am as I speak, I'm sending data.

23:10.420 --> 23:11.200
This is not Life City.

23:11.210 --> 23:12.130
But you get the point.

23:12.220 --> 23:18.700
And if you playing this, packets are coming through routers, you know, at the end of the day routers

23:18.850 --> 23:23.650
to process this because they need to send thin amount of memory called the buffer to put the packets

23:23.650 --> 23:26.620
in this memory fills up.

23:27.130 --> 23:33.010
If that fills up, if you have too many packets or your router is slower like it does a lot of stuff

23:33.010 --> 23:33.760
to pass.

23:34.510 --> 23:36.790
More work means more time.

23:36.790 --> 23:43.240
More time means queue will go longer and the buffer will fill and the buffer fills.

23:43.810 --> 23:45.550
That means you cannot accept more packets.

23:45.830 --> 23:48.190
That means you have to drop incoming packets.

23:48.190 --> 23:52.210
Any packet that comes the controller of the browser will drop the packet.

23:52.510 --> 23:55.840
And when that happens, that indicates something called congestion.

23:55.840 --> 24:02.320
That means, hey, the network is congested or these characters are having a having a hard time processing

24:02.320 --> 24:03.700
packets stop.

24:04.150 --> 24:10.360
So there is a whole solution to congestion control, control the traffic in the Internet, and that's

24:10.360 --> 24:11.380
called congestion control.

24:12.280 --> 24:16.960
For the longest time, routers always drop the packets, they drop the packet.

24:16.960 --> 24:17.650
I don't care.

24:17.830 --> 24:20.950
That's it doesn't even send any message or anything like that.

24:20.950 --> 24:22.570
Just drop it and leave it alone.

24:23.410 --> 24:26.230
You know, it doesn't even send an ICMP message.

24:26.230 --> 24:27.760
I don't think so.

24:27.760 --> 24:29.320
The client have to guess what the.

24:29.320 --> 24:30.040
Okay.

24:30.040 --> 24:31.900
My packet had timed out.

24:31.930 --> 24:33.760
I don't see an acknowledgment.

24:33.790 --> 24:37.240
I'm going to assume it's going as dropped and I'm going to assume congestion.

24:37.240 --> 24:38.050
That's what happens.

24:38.440 --> 24:43.570
It's a waste because that timeout is so long and we're wait.

24:43.810 --> 24:45.580
We need better communication.

24:45.910 --> 24:54.490
Meet explicit congestion notification the router when their buffer fills up because they are IP packets,

24:54.490 --> 24:56.290
they don't deal with layer three packets.

24:56.500 --> 24:57.960
They will take this packet and says.

24:58.930 --> 25:00.310
I'm about to drop this on my bucket.

25:00.310 --> 25:01.020
It's fall.

25:01.030 --> 25:01.840
But wait a minute.

25:01.960 --> 25:05.110
I'm going to actually I'm going to actually not drop it.

25:06.160 --> 25:08.320
My puffer is about to fill.

25:08.800 --> 25:11.380
I know I'm going to fill is in.

25:11.380 --> 25:12.670
Said the bit to one.

25:13.000 --> 25:13.270
Right.

25:13.270 --> 25:13.720
Whatever.

25:13.730 --> 25:16.360
Said it to true boom notification.

25:16.930 --> 25:19.510
I'm about to get filled and then it will actually process.

25:19.900 --> 25:26.830
So the receiver will see that bit that oh oh someone actually some of the routers experience congestion.

25:27.190 --> 25:31.690
I better tell the, uh, I better tell the receiver.

25:31.740 --> 25:36.580
And so the TCP layer takes control as we experience congestion.

25:37.030 --> 25:42.940
And then the client will start communicating at the higher levels of the TCP transport layer as again,

25:42.970 --> 25:43.970
we experience congestion.

25:44.080 --> 25:51.130
So the beauty here is with this small change, we manage to notify the both the client and the server.

25:51.670 --> 25:52.000
Right?

25:53.170 --> 25:55.720
The server will reply back to the lines with the same bit.

25:55.720 --> 26:02.650
So everybody will know eventually and and they just manage to know that there is congestion without

26:02.650 --> 26:03.730
any packets getting up.

26:04.090 --> 26:05.110
Beautiful design.

26:05.770 --> 26:10.840
I absolutely love how elegant such small to bits can do.

26:11.020 --> 26:11.130
Right.

26:11.200 --> 26:13.340
And and to be honest, I don't know why do we have to go bits right?

26:13.450 --> 26:16.120
We can go into more details, but this is the gist of it.

26:16.810 --> 26:17.470
Beautiful.

26:17.470 --> 26:19.480
I absolutely love this stuff.

26:19.840 --> 26:27.010
You know, we can learn so much as back in India from these elegant designs, you know, because we

26:27.010 --> 26:36.220
waste so much when we build applications, do we build all sort of you know, we allocate arrays like

26:36.580 --> 26:43.480
thousands and thousands of by Jason bloated Jason we duplicate keys all around.

26:43.720 --> 26:46.930
We took duplicate responses from the database.

26:46.930 --> 26:48.670
We put it everywhere.

26:48.670 --> 26:50.650
We send information we don't need.

26:50.920 --> 26:59.410
So all of this stuff really hurts me when I see a response from an API that that we just got back up,

26:59.410 --> 27:02.860
you know, we send the same value over and over again.

27:03.520 --> 27:05.230
These kind of things makes me crazy.

27:05.230 --> 27:13.780
You know, back in the old days, they had a limit to work with and they appreciate this limit today.

27:14.590 --> 27:18.220
Engineers, we don't have a limit from what?

27:18.220 --> 27:19.750
Islam I don't care.

27:19.750 --> 27:22.900
I have 700 gigabyte ram.

27:23.230 --> 27:24.430
I don't care.

27:24.430 --> 27:30.730
Let me I look at everything I want and unfortunately we lost that, you know, source of scarcity.

27:31.660 --> 27:37.270
This is just me ranting and that's pretty much this is the most important thing that I like to explain

27:37.300 --> 27:40.150
and when it comes to the header that I've ever had.

27:40.360 --> 27:40.720
All right.

27:41.020 --> 27:43.210
How about we summarize this IP packet?

27:43.210 --> 27:51.940
The IP packet is one of more elegant, you know, uh, anatomy that is, you know, the packet has headers,

27:51.940 --> 27:56.380
it's 20 bytes can go up to 60 if you have options and it is enabled.

27:56.650 --> 27:59.830
Data Section Guide Go to a 65,000 bytes.

28:00.370 --> 28:06.880
I never seen such such IP back of that lot because there is no empty you that fits it.

28:06.880 --> 28:12.370
First of all, you know, you can argue that hey, 16 bit is actually too much, but you never know.

28:12.730 --> 28:19.570
Maybe an Amazon cloned a cloud, Amazon Cloud or Microsoft Azure or Google.

28:19.750 --> 28:25.960
They build their own network and really with a large MTU that can effectively be 65,000.

28:25.960 --> 28:26.530
Who knows?

28:26.680 --> 28:28.450
They don't share this information with us.

28:28.690 --> 28:36.700
So if you have that such a large frame, you can send one IP, large IP backwards and then it fits it

28:36.700 --> 28:37.630
in a single frame.

28:37.630 --> 28:39.910
Now, I don't know the limitations of that.

28:40.120 --> 28:42.330
What can what can go wrong with that?

28:42.330 --> 28:46.180
It probably people will try to, but definitely will decrease the latency.

28:46.630 --> 28:46.930
Right.

28:47.410 --> 28:53.710
If you have your own network that all of these devices live tightly high bandwidth network I'm not going

28:53.710 --> 29:00.520
to the Internet is just between me it's on my own back in the database connect to the to the back in

29:00.520 --> 29:10.630
application all they are I don't know a hundred gigabit Ethernet and I'm to use 65 K to use and I'm

29:10.630 --> 29:11.410
going to use that.

29:12.160 --> 29:14.140
Sure you're not going to the Internet.

29:14.140 --> 29:18.370
So this is tightly local area network.

29:18.370 --> 29:21.640
So you're optimizing the heck out of everything.

29:22.000 --> 29:23.710
So I'd like to see this one day.

29:24.010 --> 29:29.260
So if someone ever, if there is an article, some wild love to read, someone actually taking advantage

29:29.260 --> 29:31.990
or if there is any limitation comes to empty use sizes.

29:34.270 --> 29:39.610
We talked about packets need to be good fragmented if it doesn't fit a frame unless you set the bed

29:39.610 --> 29:44.590
that says Hey, don't fragment the fly that we talked about, hey, don't fragment.

29:44.590 --> 29:50.410
And if you don't fragment, then if the package is too large for them to you, we fail, we drop the

29:50.410 --> 29:55.270
packet and we tell the client that, Hey, we couldn't fragment your stuff because you told us, don't

29:55.270 --> 29:55.750
fragment.

29:55.770 --> 29:55.980
Right?

29:56.530 --> 29:57.900
And that's where ICM.

29:58.640 --> 30:02.800
Uh, actually, this is where a black hole connection can happen.

30:02.810 --> 30:04.430
We're going to talk about this as well in the future.

30:05.120 --> 30:08.090
Black hole, TCP connection, Google that, right.

30:08.180 --> 30:09.230
That was the IP packet.

30:09.350 --> 30:09.560
How?

30:09.560 --> 30:11.290
I'm moving to the next lecture.
