WEBVTT

00:00.230 --> 00:00.680
Hey, guys.

00:00.680 --> 00:09.110
So this is a good question from a subud talking about, um, the sin and the accept.

00:09.140 --> 00:16.790
Q Specifically here, the question is do colonels maintain one Q each for sin and accept Q per process

00:16.790 --> 00:22.580
or the Colonel maintain contains one Q each for sin and accept.

00:22.610 --> 00:22.880
Right.

00:22.970 --> 00:27.590
So the second question is part of it is how do you maintain about these two?

00:27.620 --> 00:29.750
Is it basically fee for principle?

00:29.750 --> 00:31.760
So let's discuss this a little bit.

00:31.790 --> 00:40.100
So when we create a listening socket in a process, what happens is we specify the address.

00:40.100 --> 00:42.650
This is the IP address and this is the port.

00:42.650 --> 00:50.810
And when you do that, you get back a listening socket which is in Linux, a file basically in Linux,

00:50.810 --> 00:53.540
everything is a file file descriptor, right?

00:53.540 --> 00:59.240
And when we do that, the Linux kernel will create two queues for you.

00:59.340 --> 01:05.220
One is called the Syn Q and one is called the accept queue for that listening socket.

01:05.430 --> 01:12.660
And that, like any other files, is not bound to a process per se, right?

01:12.660 --> 01:20.700
That file and that socket can be shared with ten processes, which means ten processes can read and

01:20.700 --> 01:23.940
accept connections from that socket.

01:23.940 --> 01:33.030
So what happens is when a connection is attempted to this socket, that that is a syn request comes

01:33.030 --> 01:40.950
in with a target IP address matching the socket listener and the target port matching that 100%.

01:40.980 --> 01:48.120
Then that syn entry is added to the syn queue, which is a dedicated queue just for that listener.

01:48.360 --> 01:50.570
But the kernel immediately just replies back.

01:50.880 --> 01:52.830
Okay, acknowledge I'm good.

01:52.860 --> 01:54.810
Boom, let's just acknowledge this.

01:55.350 --> 02:00.900
And when you do that the client gets back that syn ack.

02:00.900 --> 02:01.200
Right?

02:01.200 --> 02:07.260
The acknowledgement basically you get a snack and the client gets that syn ack and replies back with

02:07.260 --> 02:09.990
what were the finishing the TCP handshake.

02:09.990 --> 02:19.530
And when the kernel receives the ack matching the the syn that it was in the syn q then you have a full

02:19.530 --> 02:20.490
fledged connection.

02:20.490 --> 02:27.240
Only then an entry is created in the accept queue with that connection.

02:27.270 --> 02:31.350
Yet up until that point we don't really have a connection yet.

02:31.380 --> 02:36.030
We have a ready to be accepted connection.

02:36.030 --> 02:43.680
Now the back end application will call a method, a system call called accept on that listener and that

02:43.680 --> 02:46.890
will pop that entry from the accept queue.

02:46.920 --> 02:47.370
Right?

02:47.370 --> 02:49.950
By that time the Syn has been popped, right?

02:49.950 --> 02:51.390
Because we have a connection.

02:51.390 --> 02:53.280
So the syn queue is now empty.

02:53.670 --> 02:58.590
Now the back end will call an accept and then go get that connection.

02:58.590 --> 03:00.210
We get a file essentially.

03:00.210 --> 03:07.080
So technically to answer a question here is any process with access, with a pointer access to that

03:07.080 --> 03:09.300
socket listener can call accept.

03:09.300 --> 03:17.250
So we have multiple processes can fight essentially to accept the connections and why you want to do

03:17.250 --> 03:23.790
this, you might say the reason is one process might not be fast enough to accept like a lot of connections,

03:23.790 --> 03:24.270
right?

03:24.420 --> 03:25.500
So that's what you do.

03:25.500 --> 03:26.130
Essentially.

03:26.130 --> 03:33.240
You accept, you spin up multiple processes sharing that single socket, all competing.

03:33.270 --> 03:40.260
The problem with this model is you get contention because because it's a queue, it has to establish

03:40.260 --> 03:41.820
a mutex, right?

03:41.820 --> 03:45.120
Like how do you pop something or push something from queue?

03:45.150 --> 03:46.680
You have to lock it, right?

03:46.770 --> 03:51.300
Otherwise, especially in a multithreaded or multiprocessor environment, you have to lock it.

03:51.300 --> 03:58.380
And when you do that, well, problems happen because now you have contention between multiple processes

03:58.380 --> 04:00.540
competing to accept connections.

04:00.540 --> 04:01.650
So that's the first part.

04:01.680 --> 04:04.350
The second part of the question is, is it simple?

04:04.380 --> 04:07.620
A is a simple really Fifo principle.

04:07.620 --> 04:08.340
I would say yes.

04:08.340 --> 04:14.250
I'm not really an expert in what is how is that actually implemented in the Linux kernel.

04:14.280 --> 04:16.620
But I would say yeah, it's a basic simple things.

04:16.620 --> 04:23.370
Unless maybe some cases like the kernel not particularly for the accept queue, but definitely for the

04:23.370 --> 04:29.250
receive queue where the kernel will say okay, we have like a lot of packets here received, what are

04:29.250 --> 04:34.830
we going to do is we're going to merge all these packets into one place essentially and combine them

04:34.830 --> 04:41.850
into one packet, just that we can shrink and remove the headers from the packet so we can merge them

04:41.850 --> 04:43.530
into fewer and fewer packets.

04:43.530 --> 04:45.060
So that is happening.

04:45.060 --> 04:48.630
But essentially I think it's going to be basic Fifo principle.

04:48.630 --> 04:48.990
Yeah.

04:48.990 --> 04:50.910
So yeah, that was a was a good question.

04:50.910 --> 04:53.910
I thought I'd get to create like a Q&amp;A section on it.

04:54.510 --> 04:55.320
See you in the next one.
