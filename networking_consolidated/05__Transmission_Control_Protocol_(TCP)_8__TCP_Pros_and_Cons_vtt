WEBVTT

00:00.180 --> 00:01.620
All right.

00:02.070 --> 00:06.300
The pros and the cons, the power and the drawback of this.

00:06.600 --> 00:09.630
And there's always a pros and cons for everything.

00:10.230 --> 00:11.760
ECB is no exception.

00:14.700 --> 00:18.180
The prose of TCP is exactly the cons of UDP.

00:18.600 --> 00:24.090
If you think about it, plus a little bit more, you're guaranteed delivery.

00:24.540 --> 00:30.870
If you send packets DCP going to control the transmission and it will guarantee that you get it.

00:31.680 --> 00:37.740
No one can send data without prior knowledge, so no you no monkey business where you spoof IP addresses

00:37.740 --> 00:39.420
and try to be put in something else.

00:39.420 --> 00:39.750
No.

00:40.380 --> 00:45.660
You get a well, you get a you got to establish a connection first to do that.

00:47.490 --> 00:52.800
Flow control and congestion controllers are two important features which we discussed in length about

00:52.800 --> 00:53.100
them.

00:53.100 --> 00:55.020
You know, very critical concepts.

00:55.410 --> 00:56.340
Order packets.

00:56.460 --> 00:59.840
No corruption or no or app level work.

00:59.850 --> 01:00.270
No.

01:00.480 --> 01:02.430
If you want to order packets.

01:03.810 --> 01:06.540
If you don't have the order package, then you have to order that.

01:06.540 --> 01:11.230
The application level I give you using UDP, you don't have to do this right with DCP.

01:11.640 --> 01:16.800
Now we're going to talk about how ordering back is actually a cons as well.

01:16.800 --> 01:21.430
A bad thing about ECP or certain cases at least be.

01:21.820 --> 01:22.830
Yeah, we've got to talk about that.

01:22.830 --> 01:24.390
So there's going to be a whole lecture about it.

01:25.290 --> 01:29.340
But for the general purpose, it's ordering packages is good.

01:29.340 --> 01:32.280
You know, if you think about secure can be easily spoofed.

01:32.400 --> 01:41.760
You know, I I'm going to say because well you still need a good authentication, you know.

01:42.330 --> 01:46.530
Well, you cannot just easily spoof because you cannot just send random data knows that.

01:46.720 --> 01:53.280
So you cannot easily dos with DCP as easy as UDP.

01:53.280 --> 01:59.190
But uh, how do you know that you are talking to who you think you are?

01:59.220 --> 01:59.820
You don't.

02:00.030 --> 02:01.050
It's an IP address.

02:01.050 --> 02:02.070
It doesn't mean anything.

02:02.850 --> 02:04.800
It doesn't have knowledge about the person.

02:05.700 --> 02:06.090
Right.

02:06.810 --> 02:12.900
That's why you need an authentication of protocols that just tells what has a certificate which is signed

02:12.900 --> 02:16.830
by a third party that proves that this guy is who say they are.

02:17.610 --> 02:20.190
Most mutual deals, you know, client and server.

02:22.590 --> 02:23.190
Cons.

02:23.190 --> 02:24.650
What's bad about DCP?

02:24.690 --> 02:25.200
Nothing.

02:25.620 --> 02:27.450
DCP is perfect, guys.

02:29.310 --> 02:29.610
Okay.

02:29.940 --> 02:32.530
Large header, overhead, competitive.

02:32.630 --> 02:37.860
You seen this 20 byte up to 60 bytes, you know, yuk.

02:38.370 --> 02:40.410
60, 20 bytes.

02:41.250 --> 02:42.080
What a shame.

02:42.090 --> 02:43.650
That's a lot of header, man.

02:44.280 --> 02:47.490
So definitely takes more bandwidth than you would be if you think about it.

02:47.940 --> 02:50.760
It's stateful, so it does consume memory compared to UDP.

02:51.990 --> 02:56.730
Here's something that I have to keep running on my server and this time with that we talked about right

02:57.030 --> 03:01.950
there, you're going to sit there and take a lot of memory, but that again, therefore a good reason

03:02.070 --> 03:07.860
and the time waits thing the states, unfortunately, we need them to protect against these attacks

03:07.860 --> 03:16.560
right there a player that's considered high latency for certain workloads know slow start congestion

03:16.560 --> 03:20.220
and EC so considered high latency for certain workloads slow start.

03:20.220 --> 03:22.200
There is congestion control, there's access.

03:22.440 --> 03:24.840
So there is a lot of stuff that is going on.

03:25.110 --> 03:29.400
So we start very small and then eventually we grow, right?

03:29.400 --> 03:32.970
There's so much limitations, right?

03:32.970 --> 03:36.120
So the latency are hit very early on.

03:36.120 --> 03:36.930
Yeah, sure.

03:37.260 --> 03:42.240
We can go very high medical action, but after what?

03:42.270 --> 03:45.660
Right after, after I talk ahead.

03:45.660 --> 03:47.220
Latency is an acknowledgement.

03:47.220 --> 03:48.480
I have to wait for acknowledgements.

03:48.480 --> 03:48.750
Right.

03:49.170 --> 03:50.730
Sometimes I don't have to.

03:50.730 --> 03:55.950
Depends like all of this to go to the more complex and complexity hurts and it does too much at a lower

03:55.950 --> 03:56.370
level.

03:57.510 --> 03:58.260
What does that mean?

04:01.180 --> 04:05.210
You see quick was invented because of a limitation in DCP.

04:05.230 --> 04:06.790
And we're going to talk about it now in a minute.

04:07.570 --> 04:13.390
So single connection to send assume this you have a single connection, a single DC big action and you

04:13.390 --> 04:20.920
want to send multiple streams of data, multiple DB requests, want to go to the same connection to

04:20.920 --> 04:23.530
the same server through one connection.

04:24.310 --> 04:25.090
How do you do it?

04:25.870 --> 04:26.200
Right.

04:26.530 --> 04:27.640
How would you do it?

04:30.010 --> 04:31.420
You would send in multiple requests.

04:31.420 --> 04:31.990
But guess what?

04:32.170 --> 04:34.130
I get request my 15 two hour segment.

04:34.160 --> 04:34.450
Right.

04:34.570 --> 04:36.240
Let's say one get request.

04:36.880 --> 04:38.410
You want to send four get requests, right.

04:39.550 --> 04:43.380
And each fits nicely into one segment for simplicity.

04:43.390 --> 04:44.930
So it's just 1.5.

04:45.160 --> 04:45.430
Right.

04:45.940 --> 04:47.440
And you send four segments.

04:48.480 --> 04:48.740
All right.

04:49.070 --> 04:51.600
And let's make this big a little bit, though.

04:51.600 --> 04:54.780
Is it for segments for get requests right in the same connection?

04:54.810 --> 04:57.390
So segment one, two, three, four, and then order.

04:57.420 --> 04:58.890
Sure, no problem.

04:59.700 --> 05:00.990
But here's one problem.

05:01.140 --> 05:05.320
Segment one, which is request, one segment, which is request to segment three, which is request

05:05.320 --> 05:05.530
three.

05:05.580 --> 05:07.170
Segment four, which is a request for four.

05:07.170 --> 05:07.950
Get request, right.

05:10.470 --> 05:13.500
And let's say segment one didn't arrive.

05:15.140 --> 05:17.810
Which is request one transfer to request one.

05:17.810 --> 05:25.610
The application stack didn't arrive by request three and saw a request to request three.

05:25.610 --> 05:27.200
Request for they all arrived.

05:27.200 --> 05:29.510
The segments arrive, but guess what?

05:29.910 --> 05:32.660
Two These are completely agnostic.

05:33.350 --> 05:34.730
Request HDB request.

05:34.730 --> 05:37.910
You know, requested to be request has nothing to do with each other as stateless.

05:38.240 --> 05:38.750
Stateless.

05:39.170 --> 05:40.920
So no request to request.

05:40.980 --> 05:42.290
Request for arrived.

05:43.040 --> 05:44.330
But now I have to wait.

05:45.520 --> 05:46.090
Why?

05:46.270 --> 05:48.820
Because stinking segment one didn't arrive.

05:49.540 --> 05:50.050
Why?

05:50.440 --> 05:51.760
Because we have to order.

05:53.030 --> 05:53.360
Because.

05:53.360 --> 05:55.050
One, two, three, four.

05:55.070 --> 05:56.300
You know how to order.

05:56.540 --> 05:57.920
You get two or three, four.

05:58.280 --> 05:59.510
So I can do anything.

05:59.750 --> 06:02.540
There is something called selective acknowledgment, but I don't want to talk about it here.

06:03.200 --> 06:04.610
So a system doesn't exist.

06:05.300 --> 06:07.030
So two or three?

06:07.040 --> 06:09.830
Four didn't arrive, but one didn't arrive.

06:09.830 --> 06:10.880
So guess what?

06:11.910 --> 06:14.160
I'm not going to do anything I can't acknowledge.

06:14.490 --> 06:15.510
So they came out.

06:17.230 --> 06:20.270
So I starved for requests.

06:20.290 --> 06:23.860
I started technically three requests just because a stinking one didn't arrive.

06:25.090 --> 06:27.220
And that's called the head of line blocking.

06:28.120 --> 06:29.410
It's trying to do too much.

06:29.410 --> 06:30.880
This is trying to do too much.

06:31.060 --> 06:36.610
Or maybe we try to overuse the DCP.

06:36.610 --> 06:46.360
I think that, yeah, we as a DGP try to use the DCP in in in a in a way that is not intended to.

06:46.360 --> 06:46.690
Right.

06:47.470 --> 06:50.920
We want to paralyze requests, but no can do that.

06:51.460 --> 06:53.650
So what happens here is just you blocked.

06:54.490 --> 07:00.520
So you have to rescind the four stinking get requests again until they arrive in order.

07:01.950 --> 07:02.400
Yikes.

07:03.360 --> 07:08.940
And that's the main problem with this appeal which led to the invention of the quick a.t b3i believe

07:08.940 --> 07:17.850
should be three was invented first, right, and then quick was invented and stripped the htp stuff,

07:17.850 --> 07:20.820
you know, the headers and all that stuff and they made it quick out of it.

07:21.300 --> 07:21.630
Right.

07:23.160 --> 07:29.610
So yeah, quick was invented because of this particular method, the ordering and TCP was this TCP head

07:29.610 --> 07:30.330
of line booking.

07:33.190 --> 07:33.550
Right.

07:35.260 --> 07:38.320
So yeah, stream one has nothing to do with stream to or request.

07:38.320 --> 07:39.870
One has nothing to do of course to.

07:40.150 --> 07:43.570
But yet both stream one stream to Baghdad must arrive in order to do that.

07:44.200 --> 07:49.000
So that's a big limitation when it comes to the ECP in this particular scenario, you know, no, no.

07:49.000 --> 07:52.450
Everybody and only everybody uses the same TV connection to send requests.

07:52.450 --> 07:52.720
Right.

07:54.220 --> 07:55.000
At the end of the day.

07:55.480 --> 07:59.320
Another common thing I've noticed people doing is this.

08:00.240 --> 08:01.570
This is the flip of this, right?

08:01.810 --> 08:08.410
I know those people in the database back in engineering community use a single TCP connection between

08:08.410 --> 08:17.010
the back end and the database, and they would expose a web tier, you know, request to receive a DB

08:17.110 --> 08:18.040
request and.

08:19.810 --> 08:21.730
The multiplex multiplex.

08:22.180 --> 08:24.210
All these are, of course, into a single DCP condition.

08:24.220 --> 08:25.120
Bad idea.

08:25.930 --> 08:26.310
Why?

08:26.350 --> 08:34.390
Because if you sending multiple query sequel queries in a single, single DCP connection, these queries

08:34.390 --> 08:35.770
will be translated into two segments.

08:36.220 --> 08:36.580
Right.

08:36.850 --> 08:37.280
Sure.

08:37.300 --> 08:38.830
Segment one will be query one.

08:38.830 --> 08:40.230
Segment two will be query three.

08:40.240 --> 08:41.020
Segment four.

08:41.260 --> 08:42.490
Three will be query three.

08:43.120 --> 08:46.510
If they are arrive in order, they will be delivered in order.

08:46.780 --> 08:47.110
Okay.

08:47.500 --> 08:49.290
Go execute sequel one Go to Go.

08:49.300 --> 08:50.830
Sequel to Go Excuse Sequel three.

08:50.830 --> 08:52.690
But what happens if Sequel three finishes first?

08:54.590 --> 08:55.160
What happened?

08:56.060 --> 08:58.610
You got the socket wall, right?

08:58.610 --> 08:59.190
The sequel.

08:59.210 --> 08:59.820
Three result.

08:59.840 --> 09:01.910
No databases will guarantee order.

09:01.910 --> 09:02.240
Right.

09:02.430 --> 09:02.520
How?

09:02.570 --> 09:02.990
You know?

09:02.990 --> 09:03.800
How do you know that?

09:04.190 --> 09:05.780
Oh, because the sequel.

09:05.780 --> 09:07.190
One, two, 3 hours arrived.

09:07.550 --> 09:08.930
Let's let's wait.

09:09.290 --> 09:12.320
No, you cannot guarantee that if you don't guarantee.

09:12.320 --> 09:12.670
Sure.

09:12.680 --> 09:14.530
But if you can't, then you.

09:14.870 --> 09:15.590
You're done.

09:16.010 --> 09:19.430
Sequel three was the fastest, so it will respond first.

09:19.430 --> 09:20.270
Now the client.

09:20.660 --> 09:23.360
How does it know which responses for which query?

09:23.720 --> 09:24.530
It doesn't.

09:25.950 --> 09:27.570
Because it's just a stream of data.

09:27.690 --> 09:32.280
There is nothing that tags anything here unless the protocol allows it.

09:32.280 --> 09:37.170
You know, if you include the query ID in the response, sure, you can do that.

09:37.680 --> 09:39.450
But how many databases do that?

09:39.840 --> 09:40.170
Right.

09:40.200 --> 09:44.000
If you were sure, by all means do it, but don't do it.

09:44.010 --> 09:46.710
That's why you use pooling when it comes to databases.

09:47.070 --> 09:51.060
I know I'm going all laboratories, but I believe this is all related.

09:51.210 --> 09:51.500
Right.

09:51.720 --> 09:52.320
It is related.

09:52.320 --> 09:52.560
Right.

09:53.190 --> 09:55.350
These are connections, databases.

09:56.130 --> 09:57.570
That's why you're here for IEEE.

09:57.570 --> 10:04.230
On to bridge that gap, guys, between what are we using on a daily basis and what we're studying in

10:04.230 --> 10:05.460
the TCP land?

10:06.990 --> 10:09.380
These are people down again.

10:09.830 --> 10:17.190
Discipline is not a good idea for VPNs just because if because we use DCB on a daily basis, if you

10:17.730 --> 10:26.520
use VPN and you establish a connection between yourself and the VPN as a TCP connection, and then took

10:26.520 --> 10:28.650
the TCP segment and encrypted that.

10:30.210 --> 10:36.330
Then you will be using a TCP inside a TCP, so you'll be doubling the congestion windows.

10:36.570 --> 10:41.580
You have double the congestion windows, you have double the receiver window, you have double the flow

10:41.580 --> 10:47.060
control, you have double the congestion window control and you have double the transport retransmission.

10:47.070 --> 10:48.390
God knows what will happen.

10:48.630 --> 10:50.520
TCP you will literally melt down.

10:51.150 --> 10:57.810
It will melt down, it will retransmit, but then it waited and then the inner TCP blocked, but the

10:57.810 --> 10:59.040
outer one didn't.

10:59.040 --> 11:02.610
And then acknowledgement of the second one received, but the inner one did.

11:03.450 --> 11:07.050
You have no idea how bad this this can get.

11:07.050 --> 11:09.150
And there is a video by a computer or file.

11:09.150 --> 11:12.480
Actually, we will explaining this if you want to watch that.

11:12.810 --> 11:16.530
And guys, this concludes our TCP section.

11:16.950 --> 11:20.780
The next thing we going to talk about is that we're now going to make a little bit of a demo, uh,

11:21.060 --> 11:24.720
spin up some, a TCP server play with a little bit.

11:24.720 --> 11:26.850
I'm going to get you to do some practical.

11:26.850 --> 11:31.500
You're probably bored of these slides, you're probably bored of me talking.

11:31.500 --> 11:37.920
So we're going to do some practical stuff, you know, listening to a server do and, you know, TCP

11:37.920 --> 11:41.240
stuff, you know, do some TCP work a little bit, though.

11:41.250 --> 11:42.960
We're going to do the final section.

11:43.050 --> 11:43.830
Note the final section.

11:43.830 --> 11:46.800
I'm going to do the next section, which is.

11:48.640 --> 11:50.560
One of the most fun sections there.

11:51.620 --> 11:52.400
Let's jump into it.
