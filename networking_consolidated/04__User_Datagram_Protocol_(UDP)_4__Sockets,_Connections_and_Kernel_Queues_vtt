WEBVTT

00:00.050 --> 00:00.890
All right.

00:00.890 --> 00:02.840
Welcome to the nitty gritty.

00:03.530 --> 00:07.760
We'll talk about connections, sockets and queues.

00:07.790 --> 00:11.210
And I'll split this into two lectures.

00:11.210 --> 00:18.680
The first part we'll talk about the in both cases we'll talk about the core kernel network data structures.

00:19.190 --> 00:25.100
But in this particular thing I'm going to talk about the sockets and connections.

00:25.100 --> 00:32.090
And then in the next one we'll talk about specifically how to read from connections and what kernel

00:32.090 --> 00:36.290
data structures does the kernel use to actually implement that.

00:36.440 --> 00:38.120
Let's jump into it.

00:38.120 --> 00:40.400
This is going to be a beautiful.

00:40.610 --> 00:44.060
And let's just swim you guys here.

00:44.060 --> 00:47.570
Let's swim and don't memorize anything.

00:47.810 --> 00:48.740
Just swim.

00:50.000 --> 00:51.050
So.

00:53.480 --> 00:54.800
First concept.

00:54.800 --> 01:03.670
Concept of a socket and a socket really when it comes to actual data structure is nothing but a struct.

01:03.730 --> 01:05.920
A struct really in C.

01:08.860 --> 01:13.840
But it's also a file descriptor, at least in Linux.

01:14.500 --> 01:21.670
No, in windows becomes an object, because in Linux everything is a is a file.

01:22.060 --> 01:31.570
But what happens here is when I listen and we talked about what is the concept of listening.

01:31.600 --> 01:31.870
Right.

01:31.870 --> 01:42.070
And the fundamentals like hey, I want to accept connections on a specific IP address and a specific

01:42.070 --> 01:44.860
Port Hussein.

01:44.860 --> 01:46.360
Use the word specific.

01:46.360 --> 01:48.670
Can I have more than an IP address in one machine?

01:48.700 --> 01:57.530
Of course, in every computer you have multiple NICs or network interface face cards.

01:58.760 --> 02:06.020
And not only that, you can technically create unlimited Virtual Network interface card, each with

02:06.020 --> 02:07.880
its own IP address.

02:08.480 --> 02:14.000
Because it's all you know, you can do anything you want, right?

02:14.210 --> 02:23.900
But ideally, you have a physical network and you have a mapped mount which have essentially that network,

02:24.200 --> 02:27.350
uh, virtual IP, not virtual IP.

02:27.380 --> 02:27.800
Sorry.

02:28.130 --> 02:32.570
It will have a neck exposed to you that you say, hey, this is my IP address.

02:32.570 --> 02:33.920
This is my subnet mask.

02:33.950 --> 02:37.820
This is my, uh, default gateway.

02:37.850 --> 02:42.740
This is my DNS resolver, IP address, all of that.

02:42.740 --> 02:43.850
It's my proxy.

02:43.880 --> 02:44.870
Stuff like that.

02:44.900 --> 02:45.410
Yeah.

02:45.560 --> 02:51.110
So you can listen on an IP and a port.

02:51.140 --> 02:52.880
It has to be those two things.

02:53.060 --> 02:53.510
Right.

02:54.380 --> 02:57.820
So that means I have four network cards.

02:57.820 --> 03:00.490
I'm listening on the IP address of this network card.

03:00.490 --> 03:04.960
You have to specify it, you know, and then you specify the port.

03:04.960 --> 03:11.710
And if you're if you've ever built a back end, you'll always see that the default is, I don't know,

03:11.740 --> 03:13.630
888 8 or 880.

03:13.660 --> 03:23.770
The port and the and the IP is the loopback default Nic, which points to myself for development purposes.

03:24.040 --> 03:24.280
Right.

03:24.280 --> 03:29.680
So that's the tcp IP 127.0.0.1.

03:29.710 --> 03:38.860
That's the IP version four for IPv6 loopback it's bracket colon colon one.

03:38.860 --> 03:41.230
That's the loopback for IPv6.

03:41.380 --> 03:44.200
But that's basically the games we're playing here.

03:45.310 --> 03:46.930
You might say I'm saying I don't have to do anything.

03:46.930 --> 03:48.940
When I listen I just call in Node.js.

03:48.970 --> 03:51.220
I could call listen and then I close the bracket.

03:51.220 --> 03:52.690
I don't know any of this stuff.

03:53.040 --> 03:56.190
Well, this is what we need to talk to you guys.

03:56.190 --> 04:03.840
When you listen, you can give the option to listen on all interfaces, which is absolutely horrible

04:03.840 --> 04:04.620
idea.

04:05.730 --> 04:06.720
Horrible.

04:06.720 --> 04:09.990
And I'm really mad that this is a default.

04:10.590 --> 04:16.920
Apparently we have to make it the default because it's too much to look up an IP.

04:16.950 --> 04:21.810
An IP can changes and and to make it easy, let's listen on all interfaces.

04:22.170 --> 04:27.240
And you do that by doing 0.0.0.04 zeros.

04:27.630 --> 04:39.330
Or I think in IPv6 bracket colon colon bracket that listens on I o IPv6 versus all IPv4 interfaces because

04:39.330 --> 04:40.050
you can have both.

04:40.080 --> 04:40.590
Right.

04:42.570 --> 04:50.520
Watch out for this because you're building a small app that does, I don't know opens a port and you

04:50.530 --> 04:54.760
accidentally deployed it in production and you wanted like really to run it locally.

04:54.760 --> 05:02.560
You just and all of a sudden you, you run it and it will listen on all production index, which happens

05:02.560 --> 05:09.700
to one of them happens to be a public IP address or a public or an IP address that is essentially mapped

05:09.730 --> 05:11.920
to some load balancer.

05:11.920 --> 05:13.510
It's public eventually.

05:13.540 --> 05:13.960
Right.

05:13.960 --> 05:17.380
So now you exposed your app to the public.

05:17.410 --> 05:26.710
That's how every single MongoDB instance and Elasticsearch data got breached, because people just listen

05:26.710 --> 05:29.260
to all interfaces and deploy it on the cloud.

05:30.700 --> 05:39.460
And and literally attackers will scan the whole web, scan all the IPv4, uh, you know, ranges looking

05:39.460 --> 05:46.030
for the Elasticsearch, Mongo, DB ports and then connect and then brute force their way.

05:46.600 --> 05:48.160
So that's really dangerous.

05:48.190 --> 05:54.120
You really want to listen on a specific port that you actually know, right?

05:54.150 --> 05:55.410
It's hard.

05:55.410 --> 05:56.940
It's difficult.

05:56.970 --> 05:58.890
It's not calm.

05:58.920 --> 06:05.940
It's it's a it it's it requires some more work, but it's secure.

06:05.970 --> 06:09.060
Now then we have listened on a port, an IP.

06:09.090 --> 06:15.150
Hussein, when you do that you call a system called code.

06:15.150 --> 06:20.280
Listen and you get back a beautiful file descriptor called socket.

06:20.280 --> 06:29.340
And this is I'm going to coin a name for it, call it listening socket file descriptor because a connection

06:29.340 --> 06:30.420
is also a socket.

06:30.420 --> 06:33.030
But that's kind of a different kind of a socket.

06:33.060 --> 06:34.950
It's the same data structure.

06:35.070 --> 06:36.000
Right.

06:36.000 --> 06:41.430
And the kernel kind of stores them in the same file, the same table data structure.

06:41.430 --> 06:46.770
But you can see that the socket has only listening socket.

06:46.820 --> 06:49.580
It doesn't have like a source IP or destination IP.

06:49.580 --> 06:50.720
It doesn't have any of that.

06:50.720 --> 06:58.250
But a connection actually is is a is an is an entity that has two sides.

06:58.250 --> 07:01.910
It has source a client and a server.

07:02.210 --> 07:04.880
So a connection is different than a socket.

07:04.880 --> 07:07.070
But I'm going to call the connection socket for now.

07:07.070 --> 07:07.700
We have a socket.

07:07.700 --> 07:08.210
Beautiful.

07:08.210 --> 07:08.870
What do we get.

07:08.900 --> 07:10.310
We get a file descriptor.

07:10.310 --> 07:11.210
Where does it live.

07:11.240 --> 07:14.030
It lives in the process ID where PCB.

07:14.060 --> 07:17.870
We know all these terms now guys we can talk safely with them.

07:18.170 --> 07:19.430
So circuit is a file.

07:19.430 --> 07:21.380
What happens if I fork got.

07:21.410 --> 07:22.040
Guess what.

07:22.040 --> 07:27.980
If you fork uh the the the files are shared right.

07:28.010 --> 07:34.970
Because you get a copy of everything that the process had at that point including file descriptors.

07:34.970 --> 07:36.050
So watch out.

07:36.050 --> 07:39.590
Maybe this is, this is by design and this is good.

07:40.280 --> 07:43.880
So when you fork careful what you fork you fork you get everything.

07:43.910 --> 07:44.990
You get a copy.

07:45.000 --> 07:46.350
Complete copy now.

07:46.350 --> 07:53.610
Copy on write can kick in, of course, and only gets you unique stuff, but essentially you have a

07:53.610 --> 07:58.830
completely new version of that.

07:58.860 --> 08:04.410
So if I listened on a process or have process A, I listened.

08:04.980 --> 08:08.370
I got a file descriptor that's the socket, the listening socket.

08:08.370 --> 08:09.630
It's absolutely useless.

08:09.630 --> 08:12.090
Just that second listening socket by itself.

08:12.090 --> 08:16.350
We need to do something to it to get actual connections.

08:16.350 --> 08:18.960
But then what happened?

08:19.890 --> 08:28.080
You fork, you get a brand new process, so you get a brand new file descriptor that technically point

08:28.110 --> 08:29.550
to the same socket.

08:29.550 --> 08:32.580
So you have one file descriptor, one file descriptor.

08:32.580 --> 08:40.080
They are two different file descriptors, but they point to the same essentially same socket.

08:40.110 --> 08:43.550
So you can accept connections here and accept connections here.

08:43.550 --> 08:53.660
And that's how essentially how socket, how you can scale acceptance of a process, which is our next

08:53.660 --> 08:54.200
topic.

08:54.200 --> 08:58.310
So we talked about let's let's go back to our single process.

08:58.340 --> 09:07.790
We have a single socket in my process for every listening socket that we create you guys we get uh something

09:07.790 --> 09:09.590
called two things.

09:09.590 --> 09:10.850
You get two queues.

09:11.960 --> 09:17.450
Uh, don't get hung up on the word queue because they are not actually implemented as a queue, because

09:17.450 --> 09:23.690
a queue is a very it's not very efficient in this particular case, actually, one of my student called

09:23.690 --> 09:24.020
that out.

09:24.020 --> 09:28.640
So I was saying like the queue seems to be very inefficient, but I and I looked at the source code.

09:28.640 --> 09:29.720
It's not a queue at all.

09:29.750 --> 09:36.770
It has a hash table, it turns out, but we talk about it as a queue because it's easier to talk through

09:36.800 --> 09:37.640
it this way.

09:37.640 --> 09:44.350
So we get something called a syn Q and this belongs to the socket.

09:44.380 --> 09:48.340
S and we get another Q called the accept.

09:48.370 --> 09:51.640
Q what are those for?

09:51.670 --> 09:57.520
Well, if you're if you're here you probably know how to establish a TCP connection.

09:57.520 --> 09:57.910
Right.

09:57.940 --> 10:03.280
We do a send and then the server sends back a syn ack.

10:03.310 --> 10:05.980
And then the client sends back an Ack.

10:05.980 --> 10:07.960
And that's called the three way handshake.

10:07.960 --> 10:13.420
And using that we get a beautiful, uh, connection.

10:13.450 --> 10:13.930
Right.

10:13.960 --> 10:15.460
But that's the handshake.

10:15.490 --> 10:21.250
To handle the handshake we, we need this sends, which is the synchronization.

10:21.250 --> 10:28.300
We use them to, to synchronize the sequence numbers that we use to label every segment, essentially.

10:29.230 --> 10:30.610
So that's the first thing syn.

10:30.640 --> 10:38.650
Q so if you have a lot of listening you get a lot of Syn cuz essentially you also get an accept Q this

10:38.660 --> 10:43.790
stores completed connections because if I did, if I am a client, I want to connect to you.

10:43.790 --> 10:46.340
I first send you a send by just sending you a send.

10:46.340 --> 10:47.900
I don't have a connection yet.

10:48.500 --> 10:51.410
We take your sin and put it in the sin queue.

10:51.440 --> 10:53.090
We don't have a full fledged connection.

10:53.090 --> 10:59.360
We only have a full fledged connection if we successfully completed the three way handshake.

10:59.390 --> 10:59.930
Right?

11:01.250 --> 11:11.600
So then you can see that as I'm putting sends here from multiple clients and from one client in India,

11:11.600 --> 11:19.190
one client in Germany, one client coming from an IP address from Lebanon, one from Bahrain, one you

11:19.190 --> 11:21.260
see, you can see that this can fill up.

11:21.260 --> 11:22.880
And then we complete the connection.

11:22.880 --> 11:24.950
So we move this stuff to the accept queue.

11:24.950 --> 11:28.790
And we have full fledged connection from Germany, from Russia.

11:28.790 --> 11:30.530
We have these connections ready.

11:30.560 --> 11:37.450
But how many can I keep in my queues before it fills up.

11:38.050 --> 11:41.320
There is a size to those, and this size is called the backlog.

11:41.320 --> 11:44.770
And you can essentially when you call listen you can specify the backlog.

11:44.770 --> 11:50.110
And this is actually exposed all the way to the client.

11:50.140 --> 11:54.220
Even in node JS you can node and you can specify how much is your backlog.

11:55.510 --> 11:57.610
Really pretty cool if you think about it.

11:57.970 --> 11:59.530
You might need a large backlog.

11:59.530 --> 12:08.920
If you have so many connections coming your way and you want to essentially you're not accepting connections

12:08.920 --> 12:09.910
fast enough.

12:10.150 --> 12:11.800
We'll talk about accepting in a minute.

12:11.830 --> 12:16.840
Now, because connections that lives here still is not with us.

12:16.870 --> 12:17.980
The back end.

12:18.010 --> 12:20.050
This is still all kernel.

12:20.620 --> 12:21.190
Okay.

12:24.070 --> 12:28.000
So now let's talk about actually creating connection.

12:28.000 --> 12:30.430
We don't we up to here we don't have a connection yet.

12:30.460 --> 12:32.380
We only have a listening socket.

12:32.380 --> 12:34.330
That is one file descriptor.

12:34.440 --> 12:37.500
Now let's talk about connections.

12:37.740 --> 12:42.330
What happened here is like completed connections are placed in the accept queue.

12:42.360 --> 12:50.070
We talked about that after you finish when you put a send put here and then the send entry comes here

12:50.070 --> 12:52.620
until we send back the synack.

12:52.620 --> 12:54.630
And then the client will send back an ack.

12:54.630 --> 12:57.540
And then we match the ack with the syn here.

12:57.540 --> 13:01.050
And then we remove it from the queue and we add it to the accept queue.

13:01.050 --> 13:05.160
And now we have a full fledged connection, but it still is not ready.

13:05.490 --> 13:07.860
You have to accept it.

13:08.640 --> 13:09.510
Who?

13:09.540 --> 13:11.580
Who is you?

13:12.000 --> 13:13.710
It's the back end application.

13:14.160 --> 13:16.830
You might say I never call this function in my life.

13:17.580 --> 13:21.240
Well, you don't, but Node.js does.

13:21.240 --> 13:22.410
Bun does.

13:24.990 --> 13:26.400
Django does.

13:26.820 --> 13:32.010
All your framework does do behind the scenes.

13:32.040 --> 13:40.090
You must call accept which which creates the file descriptor for that connection.

13:40.090 --> 13:47.050
Yes, there is a dedicated files connect descriptor file identifier for each connection.

13:48.100 --> 13:54.730
And when you do that, then we create additional two queues for the actual data that are going to be

13:54.730 --> 13:55.480
sent.

13:56.050 --> 13:56.470
Right.

13:56.470 --> 13:59.710
So when you do that you accept you're going to create a connection.

13:59.710 --> 14:06.100
That connection is going to be a file descriptor which lives on whomever or whoever, whom or who,

14:06.130 --> 14:07.090
whomever.

14:07.090 --> 14:09.340
The process that called accept.

14:09.340 --> 14:15.220
If I am process a I called accept, then the file descriptor that comes back will live in process A.

14:15.250 --> 14:21.880
If I'm process B and happen to have access to the socket somehow, and I called accept, then the file

14:21.880 --> 14:29.230
descriptor that gets created will live in my process B's PCB process control block, and it's going

14:29.260 --> 14:31.470
to be a chain of file descriptors.

14:31.470 --> 14:33.750
Maybe I'll accept 100 connections.

14:34.560 --> 14:34.890
Okay.

14:35.520 --> 14:38.040
With everyone, you get two queues.

14:38.070 --> 14:39.510
Send the queue or receive the queue.

14:39.540 --> 14:45.120
Will will come to that in the next lecture, but each of them, the send queue will go for your outgoing

14:45.120 --> 14:45.840
data.

14:45.900 --> 14:54.810
So as a server, as a back end, if I send a response to my rest API call that goes to the send queue.

14:54.840 --> 14:59.460
If my client sends a request, it goes to the receive queue.

14:59.490 --> 15:00.510
Does that make sense?

15:01.080 --> 15:02.340
And vice versa.

15:02.370 --> 15:09.240
The client also has a connection on its end as a client, and it will have a send queue and it has a

15:09.240 --> 15:10.020
receive queue.

15:10.050 --> 15:12.210
The client does not have a socket.

15:12.240 --> 15:14.160
It does not have a listening socket.

15:14.250 --> 15:17.790
It has a just a connection right.

15:17.880 --> 15:20.160
So it has a send queue and receive queue.

15:20.190 --> 15:23.190
So if a client sends a request it goes to the send queue.

15:23.190 --> 15:26.370
And then eventually the kernel pushes it out to the neck.

15:26.370 --> 15:33.890
And then it holds the receive queue cue where the response from the server will go into before we actually

15:33.890 --> 15:38.900
take the data and push it into the user space and do some stuff with it.

15:41.420 --> 15:44.090
Let's go through the simple connection establishment.

15:44.120 --> 15:46.310
Three way handshake.

15:46.340 --> 15:47.390
Three way handshake.

15:47.390 --> 15:48.260
Beautiful.

15:48.710 --> 15:49.370
We need it.

15:49.400 --> 15:50.720
We need the handshake.

15:51.230 --> 15:54.320
Otherwise we cannot exchange information we need.

15:54.350 --> 15:55.790
We need to trust.

15:55.820 --> 16:01.580
We need to exchange certain metadata between the window size and all that stuff.

16:01.580 --> 16:02.690
We need the handshake.

16:02.690 --> 16:05.750
So we do a syn syn ack ack ack.

16:06.140 --> 16:08.030
And so what happens in the back end?

16:08.180 --> 16:10.400
This is some stuff we just talked about right.

16:10.430 --> 16:13.250
A server listens on the on an address port.

16:13.280 --> 16:15.770
Client connects a kernel does a handshake.

16:15.800 --> 16:17.300
The kernel does the handshake.

16:17.330 --> 16:21.470
This is not you you you as a back end application you only call.

16:21.470 --> 16:24.530
Listen, you did not do any of this stuff.

16:24.560 --> 16:29.670
The handshake, the connections, Actions the the sink, the the accept cue.

16:29.670 --> 16:36.750
All of this is handled by the kernel, including the connection management, the three way handshake.

16:36.750 --> 16:40.740
But the kernel completes the connection, puts and accepts you.

16:40.740 --> 16:46.380
It's all the onus on you as a back end process to call accept, to accept the connection.

16:46.410 --> 16:53.190
Otherwise it's going to sit there in the accept queue and it fills up the accept queue.

16:54.030 --> 16:55.020
And I do.

16:55.050 --> 17:02.880
And I actually in my uncover in discovering a backend bottleneck course, it's a little bit intermediate

17:02.880 --> 17:06.270
to advanced course I show you, I fill up the accept queue.

17:06.300 --> 17:07.380
It's so cool.

17:07.410 --> 17:08.400
Check out that course.

17:08.400 --> 17:13.050
I fill up the accept queue and I try to connect and it's just the connection fails.

17:13.170 --> 17:13.890
Times out.

17:13.920 --> 17:20.640
It's so nice to force errors when you actually control errors because you completely understand what's

17:20.640 --> 17:21.420
going on.

17:21.450 --> 17:26.010
So I suggest you take that course to dive deep into to troubleshooting back in application.

17:26.010 --> 17:31.260
I don't think this this venue is the right venue for that because we're talking about the fundamentals

17:31.260 --> 17:32.550
of operating systems here.

17:32.580 --> 17:33.000
Right.

17:33.000 --> 17:34.440
So let's go through this a little bit.

17:34.440 --> 17:40.290
So the kernel creates a socket gets two queues send and accept client sends send.

17:40.320 --> 17:40.890
Right.

17:40.920 --> 17:48.180
So the client library understand how to speak the TCP protocol and sends a send.

17:48.330 --> 17:51.780
And it's probably done by the kernel as well.

17:51.810 --> 17:52.140
Right.

17:52.170 --> 17:59.610
Because all the library does like hey create a connection and the kernel does send and synack and the

17:59.610 --> 18:08.130
kernel adds the syn received by the client to the send queue and replies back with a syn ack and then

18:08.160 --> 18:11.100
waits in this waiting.

18:11.130 --> 18:14.490
That wait is dangerous.

18:14.970 --> 18:17.640
People exploited that wait.

18:18.660 --> 18:23.700
You know where I added a syn and I replied with the synack and I'm waiting.

18:23.730 --> 18:25.380
We're waiting for one more thing.

18:25.380 --> 18:27.150
An act, a final act.

18:27.180 --> 18:30.870
This guy, we're waiting for that final act to complete the connection.

18:31.920 --> 18:33.540
Malicious clients.

18:33.780 --> 18:34.650
That was years ago.

18:34.650 --> 18:36.540
Of course this problem was solved.

18:37.140 --> 18:41.010
Malicious clients, uh, will send us in.

18:41.040 --> 18:41.430
Will.

18:41.430 --> 18:44.700
Will will receive a snack, but will never acknowledge.

18:45.540 --> 18:47.040
What does that mean?

18:47.040 --> 18:55.740
You have a sin occupied on the sin queue on the back end listener socket.

18:55.740 --> 18:56.880
Sin queue.

18:57.870 --> 18:59.040
Now you do it again.

18:59.040 --> 18:59.940
As an attacker.

18:59.940 --> 19:01.110
I do another sin.

19:02.190 --> 19:03.360
I get a snack.

19:03.570 --> 19:08.100
We just filled up another sin slot in the sin queue.

19:10.560 --> 19:14.040
You then just say, hey, never mind, I'm not going to reply with that.

19:14.400 --> 19:17.910
So two you do it again and again and again and again.

19:18.030 --> 19:19.620
You fill up the sin queue.

19:19.650 --> 19:21.890
You just did a DDoS attack at DOS.

19:21.920 --> 19:28.070
Not really a distributed a single user could could take on the whole client.

19:28.100 --> 19:31.760
This was solved with syn cookies, right?

19:31.790 --> 19:32.990
Which has been.

19:33.110 --> 19:38.690
Now this has all the problem has been solved long, long time ago with timeouts and stuff like that.

19:38.720 --> 19:46.730
Hey, if you don't send me the syn within 520 milliseconds, you're done or something.

19:46.940 --> 19:50.090
20 is too small, like 100 milliseconds.

19:50.120 --> 19:52.160
You can configure that timeout as well.

19:52.970 --> 19:58.610
So kernel finishes the connection kernel, removes the syn from the syn queue, so frees up an entry

19:58.610 --> 19:59.030
in the syn.

19:59.060 --> 20:05.150
Queue and the kernel adds a full connection to the accept queue and the back end accepts a connection.

20:05.150 --> 20:07.220
Removes it from the accept queue.

20:07.250 --> 20:10.190
If you accept a connection, it's removed from the accept queue.

20:10.220 --> 20:18.530
If you do not accept the connection for any reason, let's say your application froze or you're just

20:18.530 --> 20:20.740
too darn slow.

20:20.890 --> 20:26.140
As a back end application, you're doing all sorts of things and you're not calling except fast enough

20:27.250 --> 20:29.050
because you have a lot of connections.

20:29.560 --> 20:32.170
You're doing all this work as a single process.

20:32.170 --> 20:33.910
You can only do so much.

20:35.920 --> 20:39.010
If you don't accept it, then it's going to rot.

20:39.100 --> 20:47.800
And the more connections there are live in the accept queue that will fail.

20:47.830 --> 20:56.080
Completed connections from being moved to the queue because the the client, the kernel cannot can no

20:56.080 --> 21:02.710
longer accept more sins because the accept queue is full and you don't really want to get into that

21:02.710 --> 21:03.520
case.

21:04.000 --> 21:10.000
You want to accept as many connections as possible, but you will also need to know if those connections

21:10.000 --> 21:11.260
are malicious or not.

21:11.290 --> 21:18.560
That's where Cloudflare and all these guys just, you know, spent tons of money and research on on

21:18.560 --> 21:22.970
understanding the behavior of attackers versus legitimate users.

21:23.480 --> 21:26.270
It's a very interesting word indeed.

21:26.480 --> 21:28.190
And of course, we talked about this.

21:28.220 --> 21:33.680
You get a beautiful file descriptor for every connection you accept.

21:34.310 --> 21:36.500
Let's go through some animations.

21:36.530 --> 21:37.820
So here is my client.

21:37.850 --> 21:41.270
Here is my process ID on the back end that is running.

21:41.780 --> 21:47.090
And of course these two lives in the kernel, which nothing but a mapped area in the process to the

21:47.090 --> 21:50.660
kernel stack, uh, to the kernel stage.

21:50.660 --> 21:51.110
Right.

21:51.140 --> 21:53.450
So accessing those queues.

21:53.450 --> 21:53.990
Right.

21:54.020 --> 21:56.930
Of course, require kernel mode, right, to be accessed.

21:56.960 --> 21:59.270
You cannot access them directly from the process.

21:59.270 --> 22:00.950
These are forbidden.

22:01.070 --> 22:01.640
Right?

22:02.000 --> 22:06.500
Uh, again, I o u ring kind of brain breaks this rule.

22:06.500 --> 22:09.620
But for normal operation, you cannot access them.

22:09.620 --> 22:10.760
They are protected.

22:11.150 --> 22:15.280
So the sin comes in here and it sits in the sin sink.

22:15.880 --> 22:16.270
Right.

22:16.300 --> 22:22.570
So the sin will have a from IP address, a from port, a destination IP address and a destination port.

22:22.570 --> 22:26.650
And that's the four tuples that uniquely identify this guy.

22:26.680 --> 22:28.060
And you put it right here.

22:28.750 --> 22:29.410
Beautiful.

22:29.440 --> 22:31.000
Now we have a Syn entry.

22:31.030 --> 22:38.740
You immediately as a kernel reply back by syn ack where the from and two from ip and from port is the

22:38.740 --> 22:42.730
whatever listening socket IP we listened to.

22:42.940 --> 22:43.690
Right.

22:43.690 --> 22:50.290
And actually whatever the client decided to connect to let's say I'm listening on all IPS, right.

22:50.470 --> 22:53.980
So the Syn the client cannot connect to all IPS.

22:53.980 --> 22:55.630
It has to specify one.

22:55.630 --> 22:59.380
And by knowing that one that becomes the source IP.

22:59.410 --> 23:09.400
In this particular case, if and only if there is a matching corresponding socket, because I drew this

23:09.400 --> 23:10.030
as a line.

23:10.030 --> 23:12.520
But there's so much stuff going on going on here.

23:12.520 --> 23:13.920
What is what is going on?

23:13.920 --> 23:24.960
If I am doing a sin and my destination IP is 1.1.1.1 and that's Cloudflare and the port is 80.

23:26.010 --> 23:32.910
Then the colonel first looks up the destination IP in certain table we're going to talk about.

23:33.030 --> 23:34.830
And that table is all right.

23:35.160 --> 23:47.160
Do I have a matching, uh, colonel entry that says I'm listening on this particular socket on this

23:47.190 --> 23:47.760
IP?

23:47.790 --> 23:49.020
Yes or no?

23:49.050 --> 23:51.570
If yes, let's do it.

23:51.660 --> 23:52.500
I accept you.

23:52.500 --> 23:56.040
If no, we get an error that no listening socket or we get an error.

23:56.730 --> 23:57.570
All right.

23:57.690 --> 24:00.600
So you see there is a matching that needs to happen.

24:00.780 --> 24:02.910
We need to look up.

24:03.600 --> 24:05.490
Imagine yourself actually implementing this.

24:05.520 --> 24:06.360
How would you do it.

24:06.390 --> 24:08.820
There's like billions of ways to do it.

24:09.150 --> 24:12.340
I'm not exaggerating, but the colonel does it a certain way.

24:12.340 --> 24:19.390
This lookup should be massively fast, possibly.

24:19.390 --> 24:21.970
Hopefully in the in the in the cache, in the CPU.

24:21.970 --> 24:28.960
All of these structures really need to be cached because you don't want to go look up that massive table

24:28.960 --> 24:36.010
with all the listeners, you know, you want to quickly look it up, and from this you would know based

24:36.010 --> 24:40.090
on that entry you would know which process it belongs to.

24:40.960 --> 24:42.520
Absolutely beautiful.

24:43.720 --> 24:45.670
So now we return the snack.

24:45.700 --> 24:48.610
Let's say we have a behaving client that replies back with an ack!

24:48.610 --> 24:50.500
Now we have a full fledged connection.

24:50.500 --> 24:53.920
The kernel removes it and adds it to the accept queue.

24:53.950 --> 24:55.780
Now we have a free connection here.

24:55.840 --> 25:07.600
Now then the process calls accept which will copy that connection, creates the content, creates a

25:07.600 --> 25:14.280
file descriptor and copy it to the to the user's file space, and it will create an entry here that

25:14.280 --> 25:23.250
says, all right, now we have an actual connection and it will create the two receive queue, the receiver

25:23.250 --> 25:26.010
queue and the send queue for that particular connection.

25:27.000 --> 25:30.210
Right now we have a file descriptor right here.

25:32.610 --> 25:34.650
So problems with accepting connections.

25:34.650 --> 25:35.940
Let's talk about some problems.

25:35.940 --> 25:38.970
Backend doesn't accept fast enough clients who don't.

25:39.000 --> 25:39.540
Ack.

25:39.570 --> 25:42.000
And we have a small backlog.

25:42.000 --> 25:46.590
If you have a small backlog you might you might have a problem with them.

25:46.830 --> 25:49.500
You know, you call accept.

25:49.500 --> 25:53.670
By the way, if you call accept and this is empty, you're blocked.

25:54.510 --> 25:55.020
Right.

25:55.080 --> 26:02.280
And that's why accept is also a candidate for asynchronous I o which we're going to talk about in another

26:02.280 --> 26:02.970
lecture.

26:03.000 --> 26:04.950
Beautiful stuff you guys.

26:06.450 --> 26:08.780
Let's talk about circuit sharding a little bit.

26:09.710 --> 26:10.160
Um.

26:13.040 --> 26:17.420
There are two different approaches to this.

26:17.450 --> 26:27.800
You know, I'll talk about this is the second one, which is literally getting a different distinct

26:27.800 --> 26:31.040
socket on the same port.

26:31.040 --> 26:39.530
So we have two processes that are not talking to each other yet listening on the same socket.

26:39.530 --> 26:53.780
So you have two sockets pointing to the same um IP port pair listener versus the other approach where

26:53.780 --> 26:59.450
you have a listening socket and you fork the process to get a copy of the file descriptor, which happens

26:59.480 --> 27:04.370
to point to the same logical physical, sorry, socket.

27:04.920 --> 27:16.830
So if those two guys, we're sharing one pair of sin and accept cue here, this is an approach where

27:16.830 --> 27:21.960
we're getting two distinct socket pointing to the same entry.

27:22.380 --> 27:27.150
And you do this using the socket option reuse port.

27:28.170 --> 27:35.130
Because normally if you listen on the same port and IP you get an error.

27:35.160 --> 27:37.290
Remember like socket already listening.

27:37.290 --> 27:38.670
That's a common error.

27:38.850 --> 27:48.720
But with this you can actually get two another socket and you can do it any number of time.

27:49.050 --> 27:53.040
Now this poses and we'll talk about this now in a minute.

27:54.300 --> 27:55.200
Nginx does it.

27:55.230 --> 27:57.360
Envoy does it HAProxy does it.

27:57.360 --> 28:04.910
And essentially what you do is you have the listener and the acceptors and the readers write the acceptors.

28:04.910 --> 28:08.390
All of these are just different threads or different processes.

28:08.390 --> 28:17.000
And this is what's called the socket sharding, where this process will have a socket and this process

28:17.000 --> 28:23.600
will also have a socket and both represent the same IP port.

28:28.160 --> 28:36.410
Now this poses a problem because if a client came in with a Syn right.

28:38.510 --> 28:42.530
And what do we do in this particular case.

28:42.590 --> 28:45.260
Which socket gets the syn.

28:45.260 --> 28:49.340
And now I'm imagining and I don't know the detail about this.

28:49.340 --> 28:58.700
And I'm imagining either you can have two sends or one syn queue for both sockets but different accept

28:58.730 --> 29:00.230
queues for sure.

29:00.760 --> 29:01.390
Right?

29:01.390 --> 29:04.210
So in this particular case process one will have an accept queue.

29:04.240 --> 29:07.660
Process two will have another accept queue for the same port.

29:07.660 --> 29:12.430
If I get a Syn on this port, complete the connection ready.

29:12.460 --> 29:15.730
The kernel will do a load balancing.

29:15.760 --> 29:19.150
It will throw the accept queue right.

29:19.390 --> 29:24.220
It will throw the first connection on the first accept queue the second one and the second, the third

29:24.220 --> 29:25.810
one and the third and so on.

29:25.840 --> 29:26.260
Right.

29:26.290 --> 29:28.750
And that's how we that's how they do it.

29:29.290 --> 29:36.940
So it will distribute the connections on different accept queues.

29:36.940 --> 29:40.480
And if it happens to have on this accept queues.

29:40.510 --> 29:46.210
This process calls accept on its own socket which will point to their own accept queue.

29:46.210 --> 29:56.140
And in this particular case we call accept on my socket which happens to use, but both are on the same

29:56.140 --> 29:58.960
Nic on the same IP and port.

29:59.000 --> 30:04.940
This is a common configuration that people do in order to scale acceptance.

30:05.270 --> 30:05.690
Right.

30:05.690 --> 30:09.710
And this is referred to as socket sharding or sharding the socket.

30:09.710 --> 30:14.210
But the Linux kernel in this particular case does the load balancing.

30:14.210 --> 30:24.080
So there is when they first introduced it, there was a lot of bugs with this because as connections

30:24.080 --> 30:31.190
close and open, we lost the balance of uh, we have a connection.

30:31.190 --> 30:32.000
You're done.

30:32.330 --> 30:36.140
The connection is like you have a nice file descriptor to go to.

30:36.470 --> 30:39.710
The problem with this is only when you accept connections.

30:39.710 --> 30:46.040
The load balancing becomes really interesting as as sockets get destroyed and recreated again.

30:46.070 --> 30:46.550
Right.

30:46.850 --> 30:49.370
So as I found this very interesting.

30:49.370 --> 30:55.340
So I thought I added another just dedicated slide for that summary.

30:55.340 --> 30:59.170
So the kernel manages the TCP IP part of networking.

30:59.200 --> 31:03.070
At least every socket represents a port, an IP right.

31:03.100 --> 31:06.580
You can with a specific socket options.

31:06.580 --> 31:15.640
When you listen, you can say, hey, I want to listen on the same port and the same IP despite someone

31:15.640 --> 31:16.780
else is using it.

31:16.810 --> 31:19.990
But it's not straightforward.

31:19.990 --> 31:29.320
You those two processes have to agree on certain, you know, on certain cookie or certain key to allow

31:29.320 --> 31:31.540
them to listen on the same port.

31:31.840 --> 31:34.900
And this is basically determined by the first process.

31:35.110 --> 31:38.590
If you don't know that key then you can't listen.

31:38.590 --> 31:39.880
Because guess what?

31:39.880 --> 31:48.400
What stops me from running a process in a server that happened to be listening on port 80.

31:48.430 --> 31:49.870
And I do.

31:49.900 --> 31:51.640
Hey socket reuse 80.

31:52.690 --> 31:57.960
I can hijack packets as a malicious process that is a bad idea.

31:57.960 --> 31:59.400
That was one of the bugs.

31:59.700 --> 32:00.660
Early, early.

32:00.660 --> 32:09.150
So to to fix that, you need to know what was the key that was used in the listening and was socket

32:09.180 --> 32:12.720
option reuse port actually allowed or not?

32:12.750 --> 32:15.150
Can you listen on the same port or not?

32:15.180 --> 32:18.480
So it's very, very interesting to learn about all of this stuff.

32:18.480 --> 32:20.250
So each connected client gets a connection.

32:20.250 --> 32:21.030
We talked about that.

32:21.030 --> 32:30.810
And kernel manages the dodos beautiful data structures you know and there is an associated cost to all

32:30.810 --> 32:37.320
this you guys you know, and it's not very clear from just the listening part because you don't really

32:37.320 --> 32:38.370
shove a lot of data.

32:38.370 --> 32:46.710
But for the connection acceptance I mean, not acceptance per se, but but just just receiving and actually

32:46.740 --> 32:49.290
dealing with packets and parsing those packets.

32:49.290 --> 32:54.280
There is so much stuff here that I'm not going to go through, and that's a course by itself.

32:54.280 --> 32:59.710
That's a book, you know, because you're talking about the actual packets.

32:59.710 --> 33:00.310
How do they.

33:01.120 --> 33:09.340
And there's like when you receive a packet from the from the receive data from the neck, the kernel

33:09.340 --> 33:11.020
creates a data structure for it.

33:11.050 --> 33:14.470
It's called skip socket buffers.

33:14.620 --> 33:15.040
Right.

33:15.040 --> 33:17.290
And then adds data to it.

33:17.290 --> 33:22.540
And then that there is metadata associated with it as overhead.

33:22.540 --> 33:29.620
So the kernel does all sorts of tricks to merge and to merge packets together and have less headers

33:29.650 --> 33:30.880
do so much stuff.

33:30.880 --> 33:39.040
So you need if you are like a beefy machine, you need to assign a core or two just for the networking

33:39.040 --> 33:40.540
stack, you know.

33:40.570 --> 33:44.590
So all right, I'm going to leave 1 or 2 just for the kernel to do this.

33:44.590 --> 33:49.510
All this complex networking stuff, you know, especially if you have like a beefy CPU.

33:49.840 --> 33:52.120
All right, guys, so let's move to the next lecture.
